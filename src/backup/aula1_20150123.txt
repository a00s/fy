#include <iostream>

#include <GL/GLee.h>         // No need to link to GL/gl.h
#include <GL/glfw.h>      // Include OpenGL Framework library
#include <GL/freeglut.h>  // Include FreeGLUT so we can easily draw spheres and calculate our viewing frustrum
#include <math.h>         // Used only for sin() and cos() functions
#include <cstdio>
#include <stdlib.h>
#include <string>
#include <sstream>

using namespace std;

const float TO_RADS = 3.141592654f / 180.0f; // The value of 1 degree in radians

GLint windowWidth = 800;                    // Width of our window
GLint windowHeight = 600;                    // Heightof our window

GLint midWindowX = windowWidth / 2;         // Middle of the window horizontally
GLint midWindowY = windowHeight / 2;         // Middle of the window vertically

GLfloat fieldOfView = 25.0f; // Define our field of view (i.e. how quickly foreshortening occurs)
GLfloat near = 1.0f; // The near (Z Axis) point of our viewing frustrum (default 1.0f)
GLfloat far = 1500.0f; // The far  (Z Axis) point of our viewing frustrum (default 1500.0f)

// Camera rotation
GLfloat camXRot = 0.0f;
GLfloat camYRot = 0.0f;
GLfloat camZRot = 0.0f;

// Camera position
GLfloat camXPos = 0.0f;
GLfloat camYPos = 0.0f;
GLfloat camZPos = 0.0f;

// Camera movement speed
GLfloat camXSpeed = 0.0f;
GLfloat camYSpeed = 0.0f;
GLfloat camZSpeed = 0.0f;

GLint frameCount = 0; // How many frames have we drawn?

// Location of the sun (i.e. how far deep into the screen is it?)
GLfloat sunZLocation = -80.0f;

// Set the light source location to be the same as the sun position
// Don't forget that the position is a FOUR COMPONENT VECTOR (with the last component as w) if you omit the last component expect to get NO LIGHT!!!
// Learnt that one the hard way... =P
//GLfloat lightPos[] = { 0.0f, 0.0f, -300.0f, 1.0f };
GLfloat lightPos[] = { 0.0f, 0.0f, 300.0f, 1.0f };

// How fast we move (higher values mean we move and strafe faster)
GLfloat movementSpeedFactor = 0.5f;

int atomos_quantidade = 0;
GLfloat caixa_tamanho = 20;
int cont_loop_electron = 0;
int cont_loop_electron_time = 50000;
static unsigned int nSeed = 5323;

GLfloat last_x;
GLfloat last_y;

// Atomo 1
GLfloat posx[100];
GLfloat posy[100];
GLfloat posz[100];
// Electron positions
GLfloat posEx[100][4];
GLfloat posEy[100][4];
GLfloat posEz[100][4];

GLfloat electron_raio[100];
GLfloat electron_y[100][4];
GLfloat electron_z[100][4];

GLint electron_arested[100][4][2]; // Primeiro eh o atomo e segundo o numero do electron
GLint electron_quantidade[100];

GLfloat velocidade_x[100]; // velocidade
GLfloat velocidade_y[100]; // velocidade
GLfloat velocidade_z[100]; // velocidade
GLfloat massa[100];

GLfloat nucleo_proximity[100];
GLfloat nucleo_proximity_free[100];
GLfloat collision_proximityE = 0.32;

GLfloat percurso[500][3];
GLint percurso_contador = -1;
GLint percurso_contador_loop = 0;

double lastTime = glfwGetTime();
string fps = "";
int contadorFrames = 0;

// Hoding any keys down?
bool holdingForward = false;
bool holdingBackward = false;
bool holdingLeftStrafe = false;
bool holdingRightStrafe = false;
bool pressionando_k = false;
bool pressionando_j = false;
bool pressionando_i = false;
bool pressionando_m = false;
bool pressionando_o = false;
bool pressionando_p = false;
bool pressionando_0 = false;
bool pressionando_l = false;
bool pressionando_8 = false;
bool pressionando_9 = false;

bool show_power_sphere = true;
bool rastreio = true;

// Function to convert degrees to radians
float toRads(const float &theAngleInDegrees) {
	return theAngleInDegrees * TO_RADS;
}

// Function to convert radians to degree
float toAngle(const float &theAngleInDegrees) {
	return theAngleInDegrees * 180 / 3.141592654f;
}

// Fix negative angles
float fixNegativeAngle(const float &Angle) {
	if (Angle >= 360) {
		return Angle - 360;
	} else if (Angle < 0) {
		return 360 + Angle;
	} else {
		return Angle;
	}
}

// Function to check if OpenGL is having issues - pass it a unique string of some kind to track down where in the code it's moaning
void checkGLError(const char * errorLocation) {
	unsigned int gle = glGetError();

	if (gle != GL_NO_ERROR) {
		cout << "GL Error discovered from caller " << errorLocation << ": ";

		switch (gle) {
		case GL_INVALID_ENUM:
			cout << "Invalid enum." << endl;
			break;

		case GL_INVALID_VALUE:
			cout << "Invalid value.\n";
			break;

		case GL_INVALID_OPERATION:
			cout << "Invalid Operation.\n";
			break;

		case GL_STACK_OVERFLOW:
			cout << "Stack overflow.\n";
			break;

		case GL_STACK_UNDERFLOW:
			cout << "Stack underflow.\n";
			break;

		case GL_OUT_OF_MEMORY:
			cout << "Out of memory.\n";
			break;
		default:
			cout << "Unknown error! Enum code is: " << gle << endl;
			break;

		} // End of switch

	} // End of if error detected

} // End of chechGLError function

void initGL() {
	// ----- GLFW Settings -----

	glfwDisable(GLFW_MOUSE_CURSOR); // Hide the mouse cursor

	// ----- Window and Projection Settings -----

	// Set the window title
	glfwSetWindowTitle("FY Project | Thiago Benazzi Maia");

	// Setup our viewport to be the entire size of the window
	glViewport(0, 0, (GLsizei) windowWidth, (GLsizei) windowHeight);

	// Change to the projection matrix, reset the matrix and set up our projection
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	// The following code is a fancy bit of math that is eqivilant to calling:
	// gluPerspective(fieldOfView/2.0f, width/height , near, far);
	// We do it this way simply to avoid requiring glu.h
	GLfloat aspectRatio = (windowWidth > windowHeight) ? float(windowWidth) / float(windowHeight) : float(windowHeight) / float(windowWidth);
	GLfloat fH = tan(float(fieldOfView / 360.0f * 3.14159f)) * near;
	GLfloat fW = fH * aspectRatio;
	glFrustum(-fW, fW, -fH, fH, near, far);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// ----- OpenGL settings -----
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set out clear colour to black, full alpha

	glfwSwapInterval(1); // Lock to vertical sync of monitor (normally 60Hz, so 60fps)

	glShadeModel(GL_SMOOTH);    // Enable (gouraud) shading

	glEnable(GL_DEPTH_TEST);    // Enable depth testing

	glClearDepth(1.0f);         // Clear the entire depth of the depth buffer

	glDepthFunc(GL_LEQUAL);	// Set our depth function to overwrite if new value less than or equal to current value

	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Ask for nicest perspective correction

	glEnable(GL_CULL_FACE); // Do not draw polygons facing away from us

	glLineWidth(2.0f);			// Set a 'chunky' line width

	// ---- Set up OpenGL lighting -----

	// Enable lighting
	glEnable(GL_LIGHTING);

	// Ambient, diffuse and specular lighting values (note that these are ALL FOUR COMPONENT VECTORS!)
	//GLfloat ambientLight[] = { 0.2f, 0.2f, 0.2f, 1.0f };
	GLfloat ambientLight[] = { 0.2f, 0.2f, 0.2f, 1.0f };
	GLfloat diffuseLight[] = { 0.7f, 0.7f, 0.7f, 1.0f };
	GLfloat specularLight[] = { 1.0f, 1.0f, 1.0f, 1.0f };

	GLint specularMagnitude = 64; // Define how "tight" our specular highlights are (larger number = smaller specular highlight). The valid range is is 1 to 128

	// Setup and enable light 0
	glLightfv(GL_LIGHT0, GL_POSITION, lightPos); // Specify the position of the light
	glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight); // Specify ambient light properties
	glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight); // Specify diffuse light properties
	glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight); // Specify specular light properties
	glEnable(GL_LIGHT0);

	// Enable colour tracking of materials
	glEnable(GL_COLOR_MATERIAL);

	// Define the shininess of the material we'll use to draw things
	GLfloat materialSpecularReflectance[] = { 1.0f, 1.0f, 1.0f, 1.0f };

	// Set Material properties to follow glColor values
	glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);

	// Use our shiny material and magnitude
	glMaterialfv(GL_FRONT, GL_SPECULAR, materialSpecularReflectance);
	glMateriali(GL_FRONT, GL_SHININESS, specularMagnitude);

	// Check for any OpenGL errors (providing the location we called the function from)
	checkGLError("InitGL");

	// ---------- Aqui vai
	for (int i = 0; i < 100; i++)
		for (int ii = 0; ii < 4; ii++)
			for (int iii = 0; iii < 4; iii++)
				electron_arested[i][ii][iii] = -1;

	last_x = 0 - 10.0;
	last_y = 0 - 10.0;
	srand((unsigned) time(0));
}

// Function to move the camera the amount we've calculated in the calculateCameraMovement function
void moveCamera() {
	camXPos += camXSpeed;
	camYPos += camYSpeed;
	camZPos += camZSpeed;
}

// Function to deal with mouse position changes, called whenever the mouse cursorm moves
void handleMouseMove(int mouseX, int mouseY) {
	GLfloat vertMouseSensitivity = 10.0f;
	GLfloat horizMouseSensitivity = 10.0f;

	//cout << "Mouse cursor is at position (" << mouseX << ", " << mouseY << endl;

	int horizMovement = mouseX - midWindowX;
	int vertMovement = mouseY - midWindowY;

	camXRot += vertMovement / vertMouseSensitivity;
	camYRot += horizMovement / horizMouseSensitivity;

	// Control looking up and down with the mouse forward/back movement
	// Limit loking up to vertically up
	if (camXRot < -90.0f) {
		camXRot = -90.0f;
	}

	// Limit looking down to vertically down
	if (camXRot > 90.0f) {
		camXRot = 90.0f;
	}

	// Looking left and right. Keep the angles in the range -180.0f (anticlockwise turn looking behind) to 180.0f (clockwise turn looking behind)
	if (camYRot < -180.0f) {
		camYRot += 360.0f;
	}

	if (camYRot > 180.0f) {
		camYRot -= 360.0f;
	}

	// Reset the mouse position to the centre of the window each frame
	glfwSetMousePos(midWindowX, midWindowY);
}

void calculaposicoes() {
	if (pressionando_k == true) {
		posx[0] = posx[0] + 0.1f;
	}

	if (pressionando_j == true) {
		posx[0] = posx[0] - 0.1f;
	}

	if (pressionando_i == true) {
		posy[0] = posy[0] + 0.1f;
	}

	if (pressionando_m == true) {
		posy[0] = posy[0] - 0.1f;
	}

	if (pressionando_o == true) {
		velocidade_x[0] -= 0.001;
	}

	if (pressionando_p == true) {
		velocidade_x[0] += 0.001;
	}

	if (pressionando_0 == true) {
		velocidade_y[0] += 0.001;
	}

	if (pressionando_l == true) {
		velocidade_y[0] -= 0.001;
	}

	if (pressionando_8 == true) {
		velocidade_z[0] -= 0.001;
	}

	if (pressionando_9 == true) {
		velocidade_z[0] += 0.001;
	}
}

// Function to calculate which direction we need to move the camera and by what amount
void calculateCameraMovement() {
	// Break up our movement into components along the X, Y and Z axis
	float camMovementXComponent = 0.0f;
	float camMovementYComponent = 0.0f;
	float camMovementZComponent = 0.0f;

	if (holdingForward == true) {
		// Control X-Axis movement
		float pitchFactor = cos(toRads(camXRot));
		camMovementXComponent += (movementSpeedFactor * float(sin(toRads(camYRot)))) * pitchFactor;

		// Control Y-Axis movement
		camMovementYComponent += movementSpeedFactor * float(sin(toRads(camXRot))) * -1.0f;

		// Control Z-Axis movement
		float yawFactor = float(cos(toRads(camXRot)));
		camMovementZComponent += (movementSpeedFactor * float(cos(toRads(camYRot))) * -1.0f) * yawFactor;
	}

	if (holdingBackward == true) {
		// Control X-Axis movement
		float pitchFactor = cos(toRads(camXRot));
		camMovementXComponent += (movementSpeedFactor * float(sin(toRads(camYRot))) * -1.0f) * pitchFactor;

		// Control Y-Axis movement
		camMovementYComponent += movementSpeedFactor * float(sin(toRads(camXRot)));

		// Control Z-Axis movement
		float yawFactor = float(cos(toRads(camXRot)));
		camMovementZComponent += (movementSpeedFactor * float(cos(toRads(camYRot)))) * yawFactor;
	}

	if (holdingLeftStrafe == true) {
		// Calculate our Y-Axis rotation in radians once here because we use it twice
		float yRotRad = toRads(camYRot);

		camMovementXComponent += -movementSpeedFactor * float(cos(yRotRad));
		camMovementZComponent += -movementSpeedFactor * float(sin(yRotRad));
	}

	if (holdingRightStrafe == true) {
		// Calculate our Y-Axis rotation in radians once here because we use it twice
		float yRotRad = toRads(camYRot);

		camMovementXComponent += movementSpeedFactor * float(cos(yRotRad));
		camMovementZComponent += movementSpeedFactor * float(sin(yRotRad));
	}

	// After combining our movements for any & all keys pressed, assign them to our camera speed along the given axis
	camXSpeed = camMovementXComponent;
	camYSpeed = camMovementYComponent;
	camZSpeed = camMovementZComponent;

	// Cap the speeds to our movementSpeedFactor (otherwise going forward and strafing at an angle is twice as fast as just going forward!)
	// X Speed cap
	if (camXSpeed > movementSpeedFactor) {
		//cout << "high capping X speed to: " << movementSpeedFactor << endl;
		camXSpeed = movementSpeedFactor;
	}
	if (camXSpeed < -movementSpeedFactor) {
		//cout << "low capping X speed to: " << movementSpeedFactor << endl;
		camXSpeed = -movementSpeedFactor;
	}

	// Y Speed cap
	if (camYSpeed > movementSpeedFactor) {
		//cout << "low capping Y speed to: " << movementSpeedFactor << endl;
		camYSpeed = movementSpeedFactor;
	}
	if (camYSpeed < -movementSpeedFactor) {
		//cout << "high capping Y speed to: " << movementSpeedFactor << endl;
		camYSpeed = -movementSpeedFactor;
	}

	// Z Speed cap
	if (camZSpeed > movementSpeedFactor) {
		//cout << "high capping Z speed to: " << movementSpeedFactor << endl;
		camZSpeed = movementSpeedFactor;
	}
	if (camZSpeed < -movementSpeedFactor) {
		//cout << "low capping Z speed to: " << movementSpeedFactor << endl;
		camZSpeed = -movementSpeedFactor;
	}
}
void show_variables() {

}

void ativa_desativa_rastreio() {
	if (rastreio) {
		rastreio = false;
	} else {
		rastreio = true;
	}
}

void ativa_desativa_forca() {
	if (show_power_sphere) {
		show_power_sphere = false;
	} else {
		show_power_sphere = true;
	}
}

void camera_position(GLfloat px, GLfloat py, GLfloat pz, GLfloat rx, GLfloat ry, GLfloat rz) {
	camXRot = rx;
	camYRot = ry;
	camZRot = rz;

	camXPos = px;
	camYPos = py;
	camZPos = pz + 10;
}

void add_energy() {
	for (GLint i = 0; i < atomos_quantidade; i++) {
		if (velocidade_x[i] > 0) {
			velocidade_x[i] += 0.01;
		} else {
			velocidade_x[i] -= 0.01;
		}
		if (velocidade_y[i] > 0) {
			velocidade_y[i] += 0.01;
		} else {
			velocidade_y[i] -= 0.01;
		}
		if (velocidade_z[i] > 0) {
			velocidade_z[i] += 0.01;
		} else {
			velocidade_z[i] -= 0.01;
		}
	}
}

void rem_energy() {
	for (GLint i = 0; i < atomos_quantidade; i++) {
		if (velocidade_x[i] > 0) {
			velocidade_x[i] -= 0.01;
		}
		if (velocidade_x[i] < 0) {
			velocidade_x[i] += 0.01;
		}
		if (velocidade_y[i] > 0) {
			velocidade_y[i] -= 0.01;
		}
		if (velocidade_y[i] < 0) {
			velocidade_y[i] += 0.01;
		}
		if (velocidade_z[i] > 0) {
			velocidade_z[i] -= 0.01;
		}
		if (velocidade_z[i] < 0) {
			velocidade_z[i] += 0.01;
		}
	}
}

void add_atom() {
	nucleo_proximity[atomos_quantidade] = 1.0;
	nucleo_proximity_free[atomos_quantidade] = 1.5;
	electron_quantidade[atomos_quantidade] = 1;
	electron_raio[atomos_quantidade] = 6.0;

	if (atomos_quantidade == 0) {
//		Electron
		massa[atomos_quantidade] = 1.0;
		posx[atomos_quantidade] = -6.0;
		posy[atomos_quantidade] = 3.0;
		posz[atomos_quantidade] = 2.0;
		velocidade_x[atomos_quantidade] = -0.01;
		velocidade_y[atomos_quantidade] = 0.0;
		velocidade_z[atomos_quantidade] = 0.0;
		electron_y[atomos_quantidade][0] = 345.0;
		electron_z[atomos_quantidade][0] = 350.0;

		//		Electron 2
//		massa[atomos_quantidade] = 1.0;
//		posx[atomos_quantidade] = -5.0;
//		posy[atomos_quantidade] = 6.0;
//		posz[atomos_quantidade] = 0.0;
//		velocidade_x[atomos_quantidade] = -0.01;
//		velocidade_y[atomos_quantidade] = 0.0;
//		velocidade_z[atomos_quantidade] = 0.0;
//		electron_y[atomos_quantidade][0] = 330.0;
//		electron_z[atomos_quantidade][0] = 0.0;

	} else if (atomos_quantidade == 1) {
//		Electron
		massa[atomos_quantidade] = 1.0;
		posx[atomos_quantidade] = 5.0;
		posy[atomos_quantidade] = 0.0;
		posz[atomos_quantidade] = 0.0;
		velocidade_x[atomos_quantidade] = 0.0;
		velocidade_y[atomos_quantidade] = 0.0;
		velocidade_z[atomos_quantidade] = 0.0;
		electron_y[atomos_quantidade][0] = 165.0;
		electron_z[atomos_quantidade][0] = 350.0;

		//		Electron 2
//		massa[atomos_quantidade] = 1.0;
//		posx[atomos_quantidade] = 5.0;
//		posy[atomos_quantidade] = 0.0;
//		posz[atomos_quantidade] = 0.0;
//		velocidade_x[atomos_quantidade] = 0.0;
//		velocidade_y[atomos_quantidade] = 0.0;
//		velocidade_z[atomos_quantidade] = 0.0;
//		electron_y[atomos_quantidade][0] = 150.0;
//		electron_z[atomos_quantidade][0] = 0.0;

	} else {
		massa[atomos_quantidade] = 1.0;
		posx[atomos_quantidade] = 5.0;
		posy[atomos_quantidade] = 0.0;
		posz[atomos_quantidade] = 0.0;
//		velocidade_x[atomos_quantidade] = -0.066667;
		velocidade_x[atomos_quantidade] = 0.2;
		velocidade_y[atomos_quantidade] = 0.3;
		velocidade_z[atomos_quantidade] = 0.1;
	}
	atomos_quantidade++;
}
// Function to set flags according to which keys are pressed or released
void handleKeypress(int theKey, int theAction) {
	// If a key is pressed, toggle the relevant key-press flag
	if (theAction == GLFW_PRESS) {

		switch (theKey) {
		case 'W':
			holdingForward = true;
			break;

		case 'S':
			holdingBackward = true;
			break;

		case 'A':
			holdingLeftStrafe = true;
			break;

		case 'D':
			holdingRightStrafe = true;
			break;

		case 'K':
			pressionando_k = true;
			break;

		case 'J':
			pressionando_j = true;
			break;

		case 'I':
			pressionando_i = true;
			break;

		case 'M':
			pressionando_m = true;
			break;

		case 'Y':
			posz[0] -= 0.5;
			break;

		case 'H':
			posz[0] += 0.5;
			break;

		case 'O':
			pressionando_o = true;
			break;

		case 'P':
			pressionando_p = true;
			break;

		case '0':
			pressionando_0 = true;
			break;

		case 'L':
			pressionando_l = true;
			break;

		case '8':
			pressionando_8 = true;
			break;

		case '9':
			pressionando_9 = true;
			break;

		case 'B':
			show_variables();
			break;

		case 'G':
			add_atom();
			break;

		case '1':
			camera_position(0.0, 0.0, caixa_tamanho, 0.0, 0.0, 0.0);
			break;

		case '2':
			camera_position(caixa_tamanho * 6.0, 0.0, -90.0, 0.0, -90.0, 0.0);
			break;

		case '3':
			camera_position(0.0, caixa_tamanho * 6.0, -90.0, 90.0, 180.0, -90.0);
			break;

		case '4':
			camera_position(caixa_tamanho * 3.0, caixa_tamanho * 3.0, caixa_tamanho, 27.0, -30.0, 0.0);
			break;

		case 'R':
			ativa_desativa_rastreio();
			break;

		case 'F':
			ativa_desativa_forca();
			break;

		case 'Z':
			rem_energy();
			break;

		case 'X':
			add_energy();
			break;

		default:
			// Do nothing...
			break;
		}
	} else // If a key is released, toggle the relevant key-release flag
	{
		switch (theKey) {
		case 'W':
			holdingForward = false;
			break;

		case 'S':
			holdingBackward = false;
			break;

		case 'A':
			holdingLeftStrafe = false;
			break;

		case 'D':
			holdingRightStrafe = false;
			break;

		case 'K':
			pressionando_k = false;
			break;

		case 'J':
			pressionando_j = false;
			break;

		case 'I':
			pressionando_i = false;
			break;

		case 'M':
			pressionando_m = false;
			break;

		case 'O':
			pressionando_o = false;
			break;

		case 'P':
			pressionando_p = false;
			break;

		case '0':
			pressionando_0 = false;
			break;

		case 'L':
			pressionando_l = false;
			break;

		case '8':
			pressionando_8 = false;
			break;

		case '9':
			pressionando_9 = false;
			break;

		default:
			// Do nothing...
			break;
		}
	}
}

// Function to draw a grid of lines
void drawGround() {
	GLfloat extent = 600.0f; // How far on the Z-Axis and X-Axis the ground extends
	GLfloat stepSize = 50.0f;  // The size of the separation between points
	GLfloat groundLevel = -50.0f;   // Where on the Y-Axis the ground is drawn

	// Set colour to white
	glColor3ub(255, 255, 255);

	// Draw our ground grid
	glBegin(GL_LINES);
	for (GLint loop = -extent; loop < extent; loop += stepSize) {
		// Draw lines along Z-Axis
		glVertex3f(loop, groundLevel, extent);
		glVertex3f(loop, groundLevel, -extent);

		// Draw lines across X-Axis
		glVertex3f(-extent, groundLevel, loop);
		glVertex3f(extent, groundLevel, loop);
	}
	glEnd();
}

void hitting_wall(GLint i, string parede) {

}

void angle_power2(GLfloat *vetor_Y, GLfloat *vetor_Z, GLfloat *forca_X, GLfloat *vetor_Y2, GLfloat *vetor_Z2, GLfloat *forca_X2) {

}

GLfloat show_distance(GLfloat x1, GLfloat x2, GLfloat y1, GLfloat y2, GLfloat z1, GLfloat z2) {
	return sqrt(pow((x2 - x1), 2.0) + pow((y2 - y1), 2.0) + pow((z2 - z1), 2.0));
}

bool angle_colision(GLint atomo1, GLint electron1, GLint atomo2, GLint electron2) {
	GLfloat d_atomo_atomo = show_distance(posx[atomo1], posx[atomo2], posy[atomo1], posy[atomo2], posz[atomo1], posz[atomo2]);
	GLfloat atomo_electron = electron_raio[atomo1] + electron_raio[atomo2];
	if (abs(d_atomo_atomo - atomo_electron) < 0.1) {
		return true;
	}
	return false;
}

bool checa_between(GLfloat numero, GLfloat comeco, GLfloat fim, GLfloat tensao) {
	return false;
}

void collision3D(GLint i, GLint ii, string tipo) {
	// In this part for 3d colision we are mostly using as a base the code from Thomas Smid (M.Sc. Physics, Ph.D. Astronomy)
	GLfloat R = 1;   //(restitution coefficient)  between 0 and 1 (1=perfectly elastic collision)
	GLfloat m1 = massa[i];  // (mass of ball 1)
	GLfloat m2 = massa[ii];  // (mass of ball 2)
	GLfloat r1 = nucleo_proximity_free[i];  // (radius of ball 1)
	GLfloat r2 = nucleo_proximity_free[ii];  // (radius of ball 2)
	GLfloat x1 = posx[i];  // (x-coordinate of ball 1)
	GLfloat y1 = posy[i];  // (y-coordinate of ball 1)
	GLfloat z1 = posz[i];  // (z-coordinate of ball 1)
	GLfloat x2 = posx[ii];  // (x-coordinate of ball 2)
	GLfloat y2 = posy[ii];  // (y-coordinate of ball 2)
	GLfloat z2 = posz[ii]; // (z-coordinate of ball 2)
	GLfloat vx1 = velocidade_x[i]; // (velocity x-component of ball 1)
	GLfloat vy1 = velocidade_y[i]; // (velocity y-component of ball 1)
	GLfloat vz1 = velocidade_z[i]; // (velocity z-component of ball 1)
	GLfloat vx2 = velocidade_x[ii]; // (velocity x-component of ball 2)
	GLfloat vy2 = velocidade_y[ii]; // (velocity y-component of ball 2)
	GLfloat vz2 = velocidade_z[ii]; // (velocity z-component of ball 2)
	GLint error = 0;    // (0: no error: balls do not collide 2: initial positions impossible (balls overlap))
	GLfloat pi, r12, m21, d, v, theta2, phi2, st, ct, sp, cp, vx1r, vy1r, vz1r, fvz1r, thetav, phiv, dr, alpha, beta, sbeta, cbeta, dc, sqs, t, a, dvz2, vx2r, vy2r, vz2r, x21, y21, z21, vx21, vy21, vz21, vx_cm, vy_cm, vz_cm;

	if (tipo == "tensao") {
		x1 = posx[i] - (2 * (posx[i] - posx[ii]));
		y1 = posy[i] - (2 * (posy[i] - posy[ii]));
		z1 = posz[i] - (2 * (posz[i] - posz[ii]));
		r1 = show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]) / 2;
		r2 = r1;
	}
//     **** initialize some variables ****
	pi = acos(-1.0E0);
	error = 0;
	r12 = r1 + r2;
	m21 = m2 / m1;
	x21 = x2 - x1;
	y21 = y2 - y1;
	z21 = z2 - z1;
	vx21 = vx2 - vx1;
	vy21 = vy2 - vy1;
	vz21 = vz2 - vz1;

	vx_cm = (m1 * vx1 + m2 * vx2) / (m1 + m2);
	vy_cm = (m1 * vy1 + m2 * vy2) / (m1 + m2);
	vz_cm = (m1 * vz1 + m2 * vz2) / (m1 + m2);

//     **** calculate relative distance and relative speed ***
	d = sqrt(x21 * x21 + y21 * y21 + z21 * z21);
//	if (tipo == "tensao") {
//		d = r1 + r2;
//	}
	v = sqrt(vx21 * vx21 + vy21 * vy21 + vz21 * vz21);

//     **** return if distance between balls smaller than sum of radii ****
	if (d > r12) {
		error = 2;
//		printf("X2 %f  X1 %f\n",x2,x1);
//		printf("Y2 %f  Y1 %f\n",y2,y1);
//		printf("Z2 %f  Z1 %f\n",z2,z1);
//		printf("X21 %f  Y21 %f  Z21 %f\n", x21, y21, z21);
//		printf("Minha dist pos: %f\n",show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]));
//		printf("Minha dist XYZ: %f\n",show_distance(x1, x2, y1, y2, z1, z2));
//		printf("Saindo 1: d:%f r12:%f r1:%f x21:%f\n", d, r12, r1,x21);
		return;
	}

//     **** return if relative speed = 0 ****
	if (v == 0) {
		error = 1;
//		printf("Saindo 2\n");
		return;
	}

//     **** shift coordinate system so that ball 1 is at the origin ***
	x2 = x21;
	y2 = y21;
	z2 = z21;

//     **** boost coordinate system so that ball 2 is resting ***
	vx1 = -vx21;
	vy1 = -vy21;
	vz1 = -vz21;

//     **** find the polar coordinates of the location of ball 2 ***
	theta2 = acos(z2 / d);
	if (x2 == 0 && y2 == 0) {
		phi2 = 0;
	} else {
		phi2 = atan2(y2, x2);
	}
	st = sin(theta2);
	ct = cos(theta2);
	sp = sin(phi2);
	cp = cos(phi2);

//     **** express the velocity vector of ball 1 in a rotated coordinate
//          system where ball 2 lies on the z-axis ******
	vx1r = ct * cp * vx1 + ct * sp * vy1 - st * vz1;
	vy1r = cp * vy1 - sp * vx1;
	vz1r = st * cp * vx1 + st * sp * vy1 + ct * vz1;
	fvz1r = vz1r / v;
	if (fvz1r > 1) {
		fvz1r = 1;
	}   // fix for possible rounding errors
	else if (fvz1r < -1) {
		fvz1r = -1;
	}
	thetav = acos(fvz1r);
	if (vx1r == 0 && vy1r == 0) {
		phiv = 0;
	} else {
		phiv = atan2(vy1r, vx1r);
	}

//     **** calculate the normalized impact parameter ***
	dr = d * sin(thetav) / r12;

//     **** return old positions and velocities if balls do not collide ***
	if (thetav > pi / 2 || fabs(dr) > 1) {
		x2 = x2 + x1;
		y2 = y2 + y1;
		z2 = z2 + z1;
		vx1 = vx1 + vx2;
		vy1 = vy1 + vy2;
		vz1 = vz1 + vz2;
		error = 1;
		return;
	}

//     **** calculate impact angles if balls do collide ***
	alpha = asin(-dr);
	beta = phiv;
	sbeta = sin(beta);
	cbeta = cos(beta);

//     **** calculate time to collision ***
	t = (d * cos(thetav) - r12 * sqrt(1 - dr * dr)) / v;

//     **** update positions and reverse the coordinate shift ***
	x2 = x2 + vx2 * t + x1;
	y2 = y2 + vy2 * t + y1;
	z2 = z2 + vz2 * t + z1;
	x1 = (vx1 + vx2) * t + x1;
	y1 = (vy1 + vy2) * t + y1;
	z1 = (vz1 + vz2) * t + z1;

//  ***  update velocities ***

	a = tan(thetav + alpha);

	dvz2 = 2 * (vz1r + a * (cbeta * vx1r + sbeta * vy1r)) / ((1 + a * a) * (1 + m21));

	vz2r = dvz2;
	vx2r = a * cbeta * dvz2;
	vy2r = a * sbeta * dvz2;
	vz1r = vz1r - m21 * vz2r;
	vx1r = vx1r - m21 * vx2r;
	vy1r = vy1r - m21 * vy2r;

//     **** rotate the velocity vectors back and add the initial velocity
//           vector of ball 2 to retrieve the original coordinate system ****

	velocidade_x[i] = ct * cp * vx1r - sp * vy1r + st * cp * vz1r + vx2;
	velocidade_y[i] = ct * sp * vx1r + cp * vy1r + st * sp * vz1r + vy2;
	velocidade_z[i] = ct * vz1r - st * vx1r + vz2;
	velocidade_x[ii] = ct * cp * vx2r - sp * vy2r + st * cp * vz2r + vx2;
	velocidade_y[ii] = ct * sp * vx2r + cp * vy2r + st * sp * vz2r + vy2;
	velocidade_z[ii] = ct * vz2r - st * vx2r + vz2;

	return;
}

void drawP(GLfloat oy, GLfloat oz, GLfloat ox) {
}

void drawE(GLfloat oy, GLfloat oz, GLfloat ox, GLint atomN, GLint electronN) {
//	printf("De %f %f %d %d\n", oy, oz, atomN, electronN);
	GLfloat cosseno = cos(toRads(oy)) * ox;
	GLfloat seno = sin(toRads(oy)) * ox;
	GLfloat cossenoZ = cos(toRads(oz)) * cosseno;
	GLfloat senoZ = sin(toRads(oz)) * cosseno;
	glTranslatef(cossenoZ, seno, senoZ);
	posEx[atomN][electronN] = posx[atomN] + cossenoZ;
	posEy[atomN][electronN] = posy[atomN] + seno;
	posEz[atomN][electronN] = posz[atomN] + senoZ;
//	printf("De %f %f\n", posx[0], posEx[0][0]);
	glutSolidSphere(0.2f, 6, 6);
	glTranslatef(-cossenoZ, -seno, -senoZ);
}

// Function to draw our spheres and position the light source
void drawScene() {
	GLfloat calcula = 0.011111 + 0.188889;
	//printf("Resultado: %f\n", calcula);
	// Clear the screen and depth buffer
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	// Reset the matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	// Move the camera to our location in space
	glRotatef(camXRot, 1.0f, 0.0f, 0.0f); // Rotate our camera on the x-axis (looking up and down)
	glRotatef(camYRot, 0.0f, 1.0f, 0.0f); // Rotate our camera on the  y-axis (looking left and right)
	glTranslatef(-camXPos, -camYPos, -camZPos); // Translate the modelviewm matrix to the position of our camera
	// Move everything "into" the screen (i.e. move 300 units along the Z-axis into the screen) so that all positions are now relative to the location of the sun
	glTranslatef(0.0f, 0.0f, sunZLocation);
	glColor3ub(255, 255, 0);
	glutWireCube(2.0 * caixa_tamanho);

	for (GLint i = 0; i < atomos_quantidade; i++) {
		if (posy[i] > caixa_tamanho) {
			velocidade_y[i] *= -1;
		} else if (posy[i] < caixa_tamanho * -1) {
			velocidade_y[i] *= -1;
		}
		if (posx[i] > caixa_tamanho) {
			velocidade_x[i] *= -1;
		} else if (posx[i] < caixa_tamanho * -1) {
			velocidade_x[i] *= -1;
		}
		if (posz[i] > caixa_tamanho) {
			velocidade_z[i] *= -1;
		} else if (posz[i] < caixa_tamanho * -1) {
			velocidade_z[i] *= -1;
		}
		// ===================== Movendo ======================
		posx[i] += velocidade_x[i];
		posy[i] += velocidade_y[i];
		posz[i] += velocidade_z[i];

		// ================ Checa colisao de nucleo ================

		//GLfloat distance_to_compare = nucleo_proximity_free[i];
		for (GLint ii = 0; ii < atomos_quantidade; ii++) {
			if (i != ii) {
				//printf("Distancia: %f\n",show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]),);

				if (show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]) <= (nucleo_proximity_free[i] + nucleo_proximity_free[ii])) {
					collision3D(i, ii, "colisao");
					bool continua_ca = true;
					// Checando pra ver se estao indo em direcao oposta
//					if (posx[i] < posx[ii]) {
//						if (velocidade_x[i] < velocidade_x[ii]) {
//							continua_ca = false;
//						}
//					} else if (posx[i] > posx[ii]) {
//						if (velocidade_x[i] > velocidade_x[ii]) {
//							continua_ca = false;
//						}
//					}
//
//					if (posy[i] < posy[ii]) {
//						if (velocidade_y[i] < velocidade_y[ii]) {
//							continua_ca = false;
//						}
//					} else if (posy[i] > posy[ii]) {
//						if (velocidade_y[i] > velocidade_y[ii]) {
//							continua_ca = false;
//						}
//					}
//
//					if (posz[i] < posz[ii]) {
//						if (velocidade_z[i] < velocidade_z[ii]) {
//							continua_ca = false;
//						}
//					} else if (posz[i] > posz[ii]) {
//						if (velocidade_z[i] > velocidade_z[ii]) {
//							continua_ca = false;
//						}
//					}

					if (continua_ca) {
						// --- COM ---------------- Original sem angulo ----------------------
						//						GLfloat dif = massa[i] - massa[ii];
						//						GLfloat sum = massa[i] + massa[ii];
						//
						//						GLfloat velocidade_x_t = (dif * velocidade_x[i] + 2 * massa[ii] * velocidade_x[ii]) / sum;
						//						GLfloat velocidade_x_t2 = (2 * massa[i] * velocidade_x[i] - dif * velocidade_x[ii]) / sum;
						//
						//						GLfloat velocidade_y_t = (dif * velocidade_y[i] + 2 * massa[ii] * velocidade_y[ii]) / sum;
						//						GLfloat velocidade_y_t2 = (2 * massa[i] * velocidade_y[i] - dif * velocidade_y[ii]) / sum;
						//
						//						GLfloat velocidade_z_t = (dif * velocidade_z[i] + 2 * massa[ii] * velocidade_z[ii]) / sum;
						//						GLfloat velocidade_z_t2 = (2 * massa[i] * velocidade_z[i] - dif * velocidade_z[ii]) / sum;
						//						velocidade_x[ii] = velocidade_x_t2;
						//						velocidade_x[i] = velocidade_x_t;
						//
						//						velocidade_y[ii] = velocidade_y_t2;
						//						velocidade_y[i] = velocidade_y_t;
						//
						//						velocidade_z[ii] = velocidade_z_t2;
						//						velocidade_z[i] = velocidade_z_t;
						// --- FIM ---------------- Original sem angulo ----------------------
						//						if (posy[i] > posy[ii]) {
						// ------------- Com duncionando angulo para B ------------------
						//							velocidade_x[i] *= -1;
						//							GLfloat dif = massa[i] - massa[ii];
						//							GLfloat sum = massa[i] + massa[ii];
						//
						//							// Devo multiplicar por 2 na sequencia pois fica espelhado
						//							GLfloat colisao_angulo = toAngle(atan2(-(posy[i]) + posy[ii], -(posx[i]) + posx[ii]));
						//							printf("Angulo: %f\n", colisao_angulo);
						//
						//							GLfloat velocidade_x_t = (dif * velocidade_x[i] + 2 * massa[ii] * velocidade_x[ii]) / sum;
						//							GLfloat velocidade_x_t2 = (2 * massa[i] * velocidade_x[i] - dif * velocidade_x[ii]) / sum;
						//
						//							GLfloat velocidade_y_t = (dif * velocidade_y[i] + 2 * massa[ii] * velocidade_y[ii]) / sum;
						//							GLfloat velocidade_y_t2 = (2 * massa[i] * velocidade_y[i] - dif * velocidade_y[ii]) / sum;
						//
						//							GLfloat velocidade_z_t = (dif * velocidade_z[i] + 2 * massa[ii] * velocidade_z[ii]) / sum;
						//							GLfloat velocidade_z_t2 = (2 * massa[i] * velocidade_z[i] - dif * velocidade_z[ii]) / sum;
						////										velocidade_x[ii] = velocidade_x_t2 * -1;
						//
						//
						////										velocidade_y[ii] = velocidade_y_t2 * -1;
						////							velocidade_y[i] = velocidade_y_t * -1;
						//
						//							velocidade_z[ii] = velocidade_z_t2 * -1;
						//							velocidade_z[i] = velocidade_z_t * -1;
						//
						//							printf("Velocidade xt:");
						//
						//							velocidade_x[i] = cos(toRads(colisao_angulo)) * velocidade_x_t * -1;
						//							velocidade_y[i] = sin(toRads(colisao_angulo)) * velocidade_x_t * -1;
						////							velocidade_y[i] = velocidade_y[ii] - velocidade_y[i];
						////							velocidade_x[i] = velocidade_x[ii] - velocidade_x[i];
						//
						//							velocidade_y[ii] = sin(toRads(colisao_angulo)) * velocidade_x_t2 * -1;
						//							velocidade_x[ii] = cos(toRads(colisao_angulo)) * velocidade_x_t2 * -1;
						// ------------- Fim duncionando angulo para B ------------------
						// --- COM ---------- Funcionando para 2D -----------------
						if (i == 0) {
							printf("Colisao\n");
//							GLfloat dx = posx[i] - posx[ii];
//							GLfloat dy = posy[i] - posy[ii];
//							GLfloat collisionision_angle = atan2(dy, dx);
//							GLfloat magnitude_1 = sqrt(velocidade_x[i] * velocidade_x[i] + velocidade_y[i] * velocidade_y[i]);
//							GLfloat magnitude_2 = sqrt(velocidade_x[ii] * velocidade_x[ii] + velocidade_y[ii] * velocidade_y[ii]);
//							GLfloat direction_1 = atan2(velocidade_y[i], velocidade_x[i]);
//							GLfloat direction_2 = atan2(velocidade_y[ii], velocidade_x[ii]);
//							GLfloat new_xspeed_1 = magnitude_1 * cos(direction_1 - collisionision_angle);
//							GLfloat new_yspeed_1 = magnitude_1 * sin(direction_1 - collisionision_angle);
//							GLfloat new_xspeed_2 = magnitude_2 * cos(direction_2 - collisionision_angle);
//							GLfloat new_yspeed_2 = magnitude_2 * sin(direction_2 - collisionision_angle);
//							GLfloat final_xspeed_1 = ((massa[i] - massa[ii]) * new_xspeed_1 + (massa[ii] + massa[ii]) * new_xspeed_2) / (massa[i] + massa[ii]);
//							GLfloat final_xspeed_2 = ((massa[i] + massa[i]) * new_xspeed_1 + (massa[ii] - massa[i]) * new_xspeed_2) / (massa[i] + massa[ii]);
//							GLfloat final_yspeed_1 = new_yspeed_1;
//							GLfloat final_yspeed_2 = new_yspeed_2;

//							velocidade_x[i] = cos(collisionision_angle) * final_xspeed_1 + cos(collisionision_angle + 3.141592654f / 2) * final_yspeed_1;
//							velocidade_y[i] = sin(collisionision_angle) * final_xspeed_1 + sin(collisionision_angle + 3.141592654f / 2) * final_yspeed_1;
//							velocidade_x[ii] = cos(collisionision_angle) * final_xspeed_2 + cos(collisionision_angle + 3.141592654f / 2) * final_yspeed_2;
//							velocidade_y[ii] = sin(collisionision_angle) * final_xspeed_2 + sin(collisionision_angle + 3.141592654f / 2) * final_yspeed_2;

//							GLfloat velocidade_x1 = cos(collisionision_angle) * final_xspeed_1 + cos(collisionision_angle + 3.141592654f / 2) * final_yspeed_1;
//							GLfloat velocidade_y1 = sin(collisionision_angle) * final_xspeed_1 + sin(collisionision_angle + 3.141592654f / 2) * final_yspeed_1;
//							GLfloat velocidade_x2 = cos(collisionision_angle) * final_xspeed_2 + cos(collisionision_angle + 3.141592654f / 2) * final_yspeed_2;
//							GLfloat velocidade_y2 = sin(collisionision_angle) * final_xspeed_2 + sin(collisionision_angle + 3.141592654f / 2) * final_yspeed_2;

							// -------------------------------------------------
//							dx = posx[i] - posx[ii];
//							dy = posz[i] - posz[ii];
//							collisionision_angle = atan2(dy, dx);
//							magnitude_1 = sqrt(velocidade_x[i] * velocidade_x[i] + velocidade_z[i] * velocidade_z[i]);
//							magnitude_2 = sqrt(velocidade_x[ii] * velocidade_x[ii] + velocidade_z[ii] * velocidade_z[ii]);
//							direction_1 = atan2(velocidade_z[i], velocidade_x[i]);
//							direction_2 = atan2(velocidade_z[ii], velocidade_x[ii]);
//							new_xspeed_1 = magnitude_1 * cos(direction_1 - collisionision_angle);
//							new_yspeed_1 = magnitude_1 * sin(direction_1 - collisionision_angle);
//							new_xspeed_2 = magnitude_2 * cos(direction_2 - collisionision_angle);
//							new_yspeed_2 = magnitude_2 * sin(direction_2 - collisionision_angle);
//							final_xspeed_1 = ((massa[i] - massa[ii]) * new_xspeed_1 + (massa[ii] + massa[ii]) * new_xspeed_2) / (massa[i] + massa[ii]);
//							final_xspeed_2 = ((massa[i] + massa[i]) * new_xspeed_1 + (massa[ii] - massa[i]) * new_xspeed_2) / (massa[i] + massa[ii]);
//							final_yspeed_1 = new_yspeed_1;
//							final_yspeed_2 = new_yspeed_2;
//
//							velocidade_x[i] = cos(collisionision_angle) * final_xspeed_1 + cos(collisionision_angle + 3.141592654f / 2) * final_yspeed_1;
//							velocidade_z[i] = sin(collisionision_angle) * final_xspeed_1 + sin(collisionision_angle + 3.141592654f / 2) * final_yspeed_1;
//							velocidade_x[ii] = cos(collisionision_angle) * final_xspeed_2 + cos(collisionision_angle + 3.141592654f / 2) * final_yspeed_2;
//							velocidade_z[ii] = sin(collisionision_angle) * final_xspeed_2 + sin(collisionision_angle + 3.141592654f / 2) * final_yspeed_2;
////
//							printf("Dx %f  Dy %f Angle %f\n", dx, dy, collisionision_angle);
//							velocidade_x[i] = (velocidade_x1 + velocidade_x[i]) / 2;
//							velocidade_y[i] = velocidade_y1;
//							velocidade_x[ii] = (velocidade_x2 + velocidade_x[ii]) / 2;
//							velocidade_y[ii] = velocidade_y2;

						}
//						collision3D(i, ii);
						//						}
						// --- FIM ---------- Funcionando para 2D -----------------

					}
				}
			}
		}

// ===================== Nucleo ======================
		if (i == 0) {
			glColor3ub(50, 255, 255);
		} else if (i == 1) {
			glColor3ub(240, 100, 50);
		} else if (i == 2) {
			glColor3ub(120, 10, 150);
		} else if (i == 3) {
			glColor3ub(80, 120, 100);
		} else if (i == 4) {
			glColor3ub(66, 97, 144);
		} else if (i == 5) {
			glColor3ub(187, 100, 55);
		} else {
			glColor3ub(200, 67, 55);
		}
		glTranslatef(posx[i], posy[i], posz[i]);
		glutSolidSphere(1.5, 30, 30);

		if (rastreio) {
			// Linha teto
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, caixa_tamanho - posy[i], 0.0);
			glEnd();

			// Linha chao
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, -caixa_tamanho - posy[i], 0.0);
			glEnd();

			// Linha direita
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(caixa_tamanho - posx[i], 0.0, 0.0);
			glEnd();

			// Linha esquerda
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(-caixa_tamanho - posx[i], 0.0, 0.0);
			glEnd();

			// Linha frente
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, 0.0, caixa_tamanho - posz[i]);
			glEnd();

			// Linha fundo
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, 0.0, -caixa_tamanho - posz[i]);
			glEnd();
		}
// ===================== Esfera Forca ======================
		if (show_power_sphere) {
			glColor3ub(255, 255, 0);
			glTranslatef(velocidade_x[i] * 5, velocidade_y[i] * 5, velocidade_z[i] * 5);
			glutSolidSphere(1.5f, 6, 6);
			glTranslatef(-velocidade_x[i] * 5, -velocidade_y[i] * 5, -velocidade_z[i] * 5);
		}
// ============================================================

// ===================== Esfera Electron ======================
		GLfloat cosseno = 0; // (X)
		GLfloat seno = 0; // (Y)
		for (GLint Es = 0; Es < electron_quantidade[i]; Es++) {

			cosseno = 0; // (X)
			seno = 0; // (Y)

			if (cont_loop_electron == cont_loop_electron_time && electron_arested[i][Es][0] == -1) {
				GLfloat resultado_l = 0;
				GLfloat resultado_l2 = 0;
				nSeed = (8253729 * nSeed + 2396403);
				resultado_l = nSeed % 359;
				nSeed = (8253729 * nSeed + 2396403);
				resultado_l2 = nSeed % 359;
				bool segue = false;
				while (!segue) {
					segue = true;
					for (GLint conte = 0; conte < electron_quantidade[i]; conte++) {
						if (conte != Es) {
							if (fabs(electron_y[i][conte] - resultado_l) > 180) {
								if (360 - fabs(electron_y[i][conte] - resultado_l) < 20.0) {
									segue = false;
									nSeed = (8253729 * nSeed + 2396403);
									resultado_l = nSeed % 359;
									conte = 0;
								}
							} else if (fabs(electron_y[i][conte] - resultado_l) < 20.0) {
								segue = false;
								nSeed = (8253729 * nSeed + 2396403);
								resultado_l = nSeed % 359;
								conte = 0;
							}
						}
					}
				}
			}
			cosseno = cos(toRads(electron_y[i][Es])) * 6.0;
			seno = sin(toRads(electron_y[i][Es])) * 6.0;
			if (electron_arested[i][Es][0] != -1 && electron_arested[electron_arested[i][Es][0]][electron_arested[i][Es][1]][0] != i && electron_arested[electron_arested[i][Es][0]][electron_arested[i][Es][1]][1] != Es) {
				electron_arested[i][Es][0] = -1;
			}
			if (electron_arested[i][Es][0] == -1) {
				glColor3ub(255, 0, 0);
			} else {
				glColor3ub(255, 200, 100);
			}
			if (electron_arested[i][Es][0] != -1) {
				glColor3ub(255, 255, 255);
				glBegin(GL_LINES);
				glVertex3f(0.0, 0.0, 0.0);
				GLfloat difx = 0.0;
				GLfloat dify = 0.0;
				GLfloat difz = 0.0;

				GLfloat difxE = 0.0;
				GLfloat difyE = 0.0;
				GLfloat difzE = 0.0;
				GLfloat distancef = show_distance(posx[i], posx[electron_arested[i][Es][0]], posy[i], posy[electron_arested[i][Es][0]], posz[i], posz[electron_arested[i][Es][0]]);
				if (posx[i] > posx[electron_arested[i][Es][0]]) {
					difx = 0 - show_distance(posx[i], posx[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difxE = electron_raio[i] * difx / distancef;
				} else {
					difx = show_distance(posx[i], posx[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difxE = electron_raio[i] * difx / distancef;
				}
				if (posy[i] > posy[electron_arested[i][Es][0]]) {
					dify = 0 - show_distance(posy[i], posy[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difyE = electron_raio[i] * dify / distancef;
					//					printf("Distance %f R %f  Posy %f Posy2 %f dify %f\n",distancef, electron_raio[i],posy[i],posy[electron_arested[i][Es][0]],dify);
				} else {
					dify = show_distance(posy[i], posy[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difyE = electron_raio[i] * dify / distancef;
					//					printf("A2\n");
				}
				if (posz[i] > posz[electron_arested[i][Es][0]]) {
					difz = 0 - show_distance(posz[i], posz[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difzE = electron_raio[i] * difz / distancef;
				} else {
					difz = show_distance(posz[i], posz[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difzE = electron_raio[i] * difz / distancef;
				}
				glVertex3f(difx, dify, difz);
				glEnd();
				if (difxE != difxE) {
					difxE = 0.0;
				}
				if (difyE != difyE) {
					difyE = 0.0;
				}
				if (difzE != difzE) {
					difzE = 0.0;
				}
				glTranslatef(difxE, difyE, difzE);
				glutSolidSphere(0.2f, 6, 6);
				glTranslatef(-difxE, -difyE, -difzE);
				posEx[i][Es] = posx[i] + difxE;
				posEy[i][Es] = posy[i] + difyE;
				posEz[i][Es] = posz[i] + difzE;
			} else {
				drawE(electron_y[i][Es], electron_z[i][Es], electron_raio[i], i, Es);
			}
		}

// ================ Checa colisao de electron ================
		bool isclose = false;
		for (GLint Es = 0; Es < electron_quantidade[i]; Es++) {
			for (GLint ii = 0; ii < atomos_quantidade; ii++) {
				if (i != ii) {
					for (GLint Es2 = 0; Es2 < electron_quantidade[i]; Es2++) {
						if (show_distance(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2], posEz[i][Es], posEz[ii][Es2]) <= collision_proximityE) {
							isclose = true;
							if (angle_colision(i, Es, ii, Es2)) {
								if (electron_arested[ii][Es2][0] != -1 && electron_arested[ii][Es2][0] != i && electron_arested[ii][Es2][1] != Es) {
								} else if (electron_arested[i][Es][0] == -1) {
									printf("Alterando electron\n");
									electron_arested[i][Es][0] = ii;
									electron_arested[i][Es][1] = Es2;
									electron_arested[ii][Es2][0] = i;
									electron_arested[ii][Es2][1] = Es;
									printf("Alterando forcas %d\n", electron_arested[i][Es][0]);
//									GLfloat forcat = forca_x[i];
//									forca_x[i] = forca_x[ii];
//									forca_x[ii] = forcat;

									// COMECO FUNCIONANDO ------------------------------
//									if (posy[i] > posy[ii]) {
//										velocidade_x[i] *= -1;
//										GLfloat dif = massa[i] - massa[ii];
//										GLfloat sum = massa[i] + massa[ii];
//
//										// Devo multiplicar por 2 na sequencia pois fica espelhado
//										GLfloat colisao_angulo = toAngle(atan2(-(posy[i]) + posy[ii], -(posx[i]) + posx[ii]));
//										printf("Angulo: %f\n", colisao_angulo);
//
//										GLfloat velocidade_x_t = (dif * velocidade_x[i] + 2 * massa[ii] * velocidade_x[ii]) / sum;
//										GLfloat velocidade_x_t2 = (2 * massa[i] * velocidade_x[i] - dif * velocidade_x[ii]) / sum;
//
//										GLfloat velocidade_y_t = (dif * velocidade_y[i] + 2 * massa[ii] * velocidade_y[ii]) / sum;
//										GLfloat velocidade_y_t2 = (2 * massa[i] * velocidade_y[i] - dif * velocidade_y[ii]) / sum;
//
//										GLfloat velocidade_z_t = (dif * velocidade_z[i] + 2 * massa[ii] * velocidade_z[ii]) / sum;
//										GLfloat velocidade_z_t2 = (2 * massa[i] * velocidade_z[i] - dif * velocidade_z[ii]) / sum;
////										velocidade_x[ii] = velocidade_x_t2 * -1;
//										velocidade_x[i] = velocidade_x_t * -1;
//
////										velocidade_y[ii] = velocidade_y_t2 * -1;
//										velocidade_y[i] = velocidade_y_t * -1;
//
//										velocidade_z[ii] = velocidade_z_t2 * -1;
//										velocidade_z[i] = velocidade_z_t * -1;
//
//										velocidade_y[ii] = sin(toRads(colisao_angulo)) * velocidade_x_t2 * -1;
//										velocidade_x[ii] = cos(toRads(colisao_angulo)) * velocidade_x_t2 * -1;
//									}
									// FIM FUNCIONANDO ----------------------------------------
									collision3D(i, ii, "tensao");
								}
//								if (i == 0) {
//								if (electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
//										if (abs(show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii])) <= (electron_raio[i] + electron_raio[ii]) + tensao[i] + tensao[ii]) {
//									if (abs(show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii])) <= (electron_raio[i] + electron_raio[ii])) {
//										GLfloat d_atomo_atomo = show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]);
//										GLfloat angulo_f = toAngle(fabs(posy[i] - posy[ii]) / d_atomo_atomo);
//										if (posy[i] > posy[ii] && angulo_f < 180) {
//											angulo_f += 180;
//										}
//
////											printf("Angulof: %f Ay: %f\n", angulo_f, forca_y[i]);
//									}
//								}
//								}
							}
						}
//						if (electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
//							if (abs(show_distance(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii])) <= (electron_raio[i] + electron_raio[ii])) {
//							} else {
//								electron_arested[i][Es][0] = -1;
//								electron_arested[ii][Es2][0] = -1;
//							}
//						} else if (electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
//							printf("AE1\n");
//						}
					}
				}
			}
		}
		glTranslatef(-posx[i], -posy[i], -posz[i]);
// ================ Checa colisao de nucleo com electron ================

		if (cont_loop_electron == cont_loop_electron_time) {
			cont_loop_electron = 0;
		}
		cont_loop_electron++;

// ===================================================
	}
// Monta percurso
	if (massa[0] != 0) {
		for (GLint is = 0; is <= percurso_contador; is++) {
			glColor3ub(255, 255, 255);
			glTranslatef(percurso[is][0], percurso[is][1], percurso[is][2]);
			glutSolidSphere(0.1f, 6, 6);
			glTranslatef(-percurso[is][0], -percurso[is][1], -percurso[is][2]);
		}
		// Adiciona posicao atual ao percurso
		if (rastreio) {
			if (percurso_contador_loop == 10 && percurso_contador < 498) {
				percurso_contador++;
				percurso[percurso_contador][0] = posx[0];
				percurso[percurso_contador][1] = posy[0];
				percurso[percurso_contador][2] = posz[0];
				percurso_contador_loop = 0;
			}
			percurso_contador_loop++;
		}
	}
	// -----------------------------------------------------------
	contadorFrames++;
	double currentTime = glfwGetTime();
	if (currentTime - lastTime >= 1.0) {
		stringstream ss;
		ss << (1000.0 / double(contadorFrames));
		fps = ss.str();
		contadorFrames = 0;
		lastTime += 1.0;
	}

	// Imprime texto na tela
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D(0.0, windowWidth, 0.0, windowHeight);
	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();
	glColor3f(0.0, 1.0, 0.0); // Green
	glRasterPos2i(10, 10);
	void * font = GLUT_BITMAP_9_BY_15;
	for (string::iterator i = fps.begin(); i != fps.end(); ++i) {
		char c = *i;
		glutBitmapCharacter(font, c);
	}
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();

	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
// ----- Stop Drawing Stuff! ------
	glfwSwapBuffers();	// Swap the buffers to display the scene (so we don't have to watch it being drawn!)
}

// Called like:
//changeThem(&a, &b);

// Fire it up...
int main(int argc, char **argv) {
	cout << "Controls: Use WSAD and the mouse to move around!" << endl;

// Frame counter and window settings variables
	int redBits = 8, greenBits = 8, blueBits = 8;
	int alphaBits = 8, depthBits = 24, stencilBits = 0;

// Flag to keep our main loop running
	bool running = true;

// ----- Intialiase FreeGLUT -----

// Note: We're only using freeGLUT to draw some spheres, so if you modify the code to not include any calls
// to glutSolidSphere, then you don't need this, the header or the lib...
	glutInit(&argc, argv);

// Initialise GLFW
	glfwInit();

// Ask for 4x AntiAliasing (this doesn't mean we'll get it - it'll work only if the GLX_ARB_multisample extension is available)
// Note: Hints must be provided BEFORE the window is opened! But we can't query for it with GLEE until the window is opened! Catch 22!
	glfwOpenWindowHint(GLFW_FSAA_SAMPLES, 4);

// Create a window
	if (!glfwOpenWindow(windowWidth, windowHeight, redBits, greenBits, blueBits, alphaBits, depthBits, stencilBits, GLFW_WINDOW)) {
		cout << "Failed to open window!" << endl;
		glfwTerminate();
		return 0;
	}

// ----- Initialise GLEE -----

// Initialise GLee once we've got a rendering context
// Note: We don't really have to do this because it's called automatically, but if we do it - we KNOW it's been called!
	GLeeInit();

// Check for the OpenGL extension which allows us to use vsync
	if (GLEE_GLX_SGI_swap_control) {
		cout << "Extension found: GLX_SGI_swap_control (vsync can be used)." << endl;
		glfwSwapInterval(1);
	} else {
		cout << "Extension NOT found: GLX_SGI_swap_control (vsync cannot be used)." << endl;
		glfwSwapInterval(0);
	}

// Check for the OpenGL extension which allows us to use antialiasing
	if (GLEE_ARB_multitexture) {
		cout << "Extension found: GLX_ARB_multitexture (anti-aliasing can be used)." << endl;

// If the extension's available, we likely got anti-aliasing, so disable line smoothing as it comes free with the AA
		glDisable(GL_LINE_SMOOTH);
	} else {
		cout << "Extension NOT found: GLX_ARB_multitexture (anti-aliasing cannot be used)." << endl;

// If the extention's not available, turn on line smoothing
		glEnable(GL_LINE_SMOOTH);
	}

// Set the mouse cursor to the centre of our window
	glfwSetMousePos(midWindowX, midWindowY);

// Call our initGL function to set up our OpenGL options
	initGL();

// Specify the function which should execute when a key is pressed or released
	glfwSetKeyCallback(handleKeypress);

// Specify the function which should execute when the mouse is moved
	glfwSetMousePosCallback(handleMouseMove);

	while (running == true) {
		calculaposicoes();

// Draw our scene
		drawScene();

// Calculate our camera movement
		calculateCameraMovement();

// Move our camera
		moveCamera();

// Increase our frame counter
		frameCount++;

// Check for any OpenGL errors (providing the location we called the function from)
		checkGLError("Main loop");

// exit if ESC was pressed or window was closed
		running = !glfwGetKey(GLFW_KEY_ESC) && glfwGetWindowParam(GLFW_OPENED);
	}

// Clean up GLFW and exit
	glfwTerminate();

	return 0;
}
