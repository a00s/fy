#include <iostream>

#include <GL/GLee.h>         // No need to link to GL/gl.h
#include <GL/glfw.h>      // Include OpenGL Framework library
#include <GL/freeglut.h>  // Include FreeGLUT so we can easily draw spheres and calculate our viewing frustrum
#include <math.h>         // Used only for sin() and cos() functions
#include <cstdio>
#include <stdlib.h>
#include <string>

using namespace std;

const float TO_RADS = 3.141592654f / 180.0f; // The value of 1 degree in radians

GLint windowWidth = 800;                    // Width of our window
GLint windowHeight = 600;                    // Heightof our window

GLint midWindowX = windowWidth / 2;         // Middle of the window horizontally
GLint midWindowY = windowHeight / 2;         // Middle of the window vertically

GLfloat fieldOfView = 25.0f; // Define our field of view (i.e. how quickly foreshortening occurs)
GLfloat near = 1.0f; // The near (Z Axis) point of our viewing frustrum (default 1.0f)
GLfloat far = 1500.0f; // The far  (Z Axis) point of our viewing frustrum (default 1500.0f)

// Camera rotation
GLfloat camXRot = 0.0f;
GLfloat camYRot = 0.0f;
GLfloat camZRot = 0.0f;

// Camera position
GLfloat camXPos = 0.0f;
GLfloat camYPos = 0.0f;
GLfloat camZPos = 0.0f;

// Camera movement speed
GLfloat camXSpeed = 0.0f;
GLfloat camYSpeed = 0.0f;
GLfloat camZSpeed = 0.0f;

GLint frameCount = 0; // How many frames have we drawn?

// Location of the sun (i.e. how far deep into the screen is it?)
GLfloat sunZLocation = -80.0f;

// Set the light source location to be the same as the sun position
// Don't forget that the position is a FOUR COMPONENT VECTOR (with the last component as w) if you omit the last component expect to get NO LIGHT!!!
// Learnt that one the hard way... =P
//GLfloat lightPos[] = { 0.0f, 0.0f, -300.0f, 1.0f };
GLfloat lightPos[] = { 0.0f, 0.0f, 300.0f, 1.0f };

// How fast we move (higher values mean we move and strafe faster)
GLfloat movementSpeedFactor = 3.0f;

int atomos_quantidade = 0;
//int electron_quantidade = 0;
GLfloat caixa_tamanho = 20;
//GLfloat collision_proximity = 7.0;
GLfloat collision_proximityE = 0.32;
GLfloat electron_power = 10.0;
int angle_proximity = 20;
int cont_loop_electron = 0;
int cont_loop_electron_time = 50000;

static unsigned int nSeed = 5323;

GLfloat last_x;
GLfloat last_y;

// Atomo 1
GLfloat posx[100];
GLfloat posy[100];
GLfloat posz[100];
// Electron positions
GLfloat posEx[100][4];
GLfloat posEy[100][4];
GLfloat posEz[100][4];

GLfloat electron_raio[100];
GLfloat electron_y[100][4];
GLfloat electron_z[100][4];
GLint electron_arested[100][4][2]; // Primeiro eh o atomo e segundo o numero do electron
GLint electron_quantidade[100];

GLfloat tensao[100];  // quanta forca electrons vao se segurar
GLfloat tensao_giro[100];  // Velocidade em que o angulo muda quando tem colisao de electrons
GLfloat forca_x[100]; // distancia
GLfloat forca_y[100]; // angulo
GLfloat forca_z[100]; // angulo
GLfloat nucleo_proximity[100];
GLfloat nucleo_proximity_free[100];

GLfloat velocidade_x[100]; // velocidade
GLfloat velocidade_y[100]; // velocidade
GLfloat velocidade_z[100]; // velocidade

// Hoding any keys down?
bool holdingForward = false;
bool holdingBackward = false;
bool holdingLeftStrafe = false;
bool holdingRightStrafe = false;
bool pressionando_k = false;
bool pressionando_j = false;
bool pressionando_i = false;
bool pressionando_m = false;
bool pressionando_o = false;
bool pressionando_p = false;
bool pressionando_0 = false;
bool pressionando_l = false;
bool pressionando_8 = false;
bool pressionando_9 = false;

bool show_power_sphere = true;
bool rastreio = true;

// Function to convert degrees to radians
float toRads(const float &theAngleInDegrees) {
	return theAngleInDegrees * TO_RADS;
}

// Function to convert radians to degree
float toAngle(const float &theAngleInDegrees) {
	return theAngleInDegrees * 180 / 3.141592654f;
}

// Fix negative angles
float fixNegativeAngle(const float &Angle) {
	if (Angle >= 360) {
		return Angle - 360;
	} else if (Angle < 0) {
		return 360 + Angle;
	} else {
		return Angle;
	}
}

// Function to check if OpenGL is having issues - pass it a unique string of some kind to track down where in the code it's moaning
void checkGLError(const char * errorLocation) {
	unsigned int gle = glGetError();

	if (gle != GL_NO_ERROR) {
		cout << "GL Error discovered from caller " << errorLocation << ": ";

		switch (gle) {
		case GL_INVALID_ENUM:
			cout << "Invalid enum." << endl;
			break;

		case GL_INVALID_VALUE:
			cout << "Invalid value.\n";
			break;

		case GL_INVALID_OPERATION:
			cout << "Invalid Operation.\n";
			break;

		case GL_STACK_OVERFLOW:
			cout << "Stack overflow.\n";
			break;

		case GL_STACK_UNDERFLOW:
			cout << "Stack underflow.\n";
			break;

		case GL_OUT_OF_MEMORY:
			cout << "Out of memory.\n";
			break;
		default:
			cout << "Unknown error! Enum code is: " << gle << endl;
			break;

		} // End of switch

	} // End of if error detected

} // End of chechGLError function

void initGL() {
	// ----- GLFW Settings -----

	glfwDisable(GLFW_MOUSE_CURSOR); // Hide the mouse cursor

	// ----- Window and Projection Settings -----

	// Set the window title
	glfwSetWindowTitle("FY Project | Thiago Benazzi Maia");

	// Setup our viewport to be the entire size of the window
	glViewport(0, 0, (GLsizei) windowWidth, (GLsizei) windowHeight);

	// Change to the projection matrix, reset the matrix and set up our projection
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();

	// The following code is a fancy bit of math that is eqivilant to calling:
	// gluPerspective(fieldOfView/2.0f, width/height , near, far);
	// We do it this way simply to avoid requiring glu.h
	GLfloat aspectRatio = (windowWidth > windowHeight) ? float(windowWidth) / float(windowHeight) : float(windowHeight) / float(windowWidth);
	GLfloat fH = tan(float(fieldOfView / 360.0f * 3.14159f)) * near;
	GLfloat fW = fH * aspectRatio;
	glFrustum(-fW, fW, -fH, fH, near, far);

	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();

	// ----- OpenGL settings -----
	glClearColor(0.0f, 0.0f, 0.0f, 1.0f); // Set out clear colour to black, full alpha

	glfwSwapInterval(1); // Lock to vertical sync of monitor (normally 60Hz, so 60fps)

	glShadeModel(GL_SMOOTH);    // Enable (gouraud) shading

	glEnable(GL_DEPTH_TEST);    // Enable depth testing

	glClearDepth(1.0f);         // Clear the entire depth of the depth buffer

	glDepthFunc(GL_LEQUAL);	// Set our depth function to overwrite if new value less than or equal to current value

	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // Ask for nicest perspective correction

	glEnable(GL_CULL_FACE); // Do not draw polygons facing away from us

	glLineWidth(2.0f);			// Set a 'chunky' line width

	// ---- Set up OpenGL lighting -----

	// Enable lighting
	glEnable(GL_LIGHTING);

	// Ambient, diffuse and specular lighting values (note that these are ALL FOUR COMPONENT VECTORS!)
	//GLfloat ambientLight[] = { 0.2f, 0.2f, 0.2f, 1.0f };
	GLfloat ambientLight[] = { 0.2f, 0.2f, 0.2f, 1.0f };
	GLfloat diffuseLight[] = { 0.7f, 0.7f, 0.7f, 1.0f };
	GLfloat specularLight[] = { 1.0f, 1.0f, 1.0f, 1.0f };

	GLint specularMagnitude = 64; // Define how "tight" our specular highlights are (larger number = smaller specular highlight). The valid range is is 1 to 128

	// Setup and enable light 0
	glLightfv(GL_LIGHT0, GL_POSITION, lightPos); // Specify the position of the light
	glLightfv(GL_LIGHT0, GL_AMBIENT, ambientLight); // Specify ambient light properties
	glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuseLight); // Specify diffuse light properties
	glLightfv(GL_LIGHT0, GL_SPECULAR, specularLight); // Specify specular light properties
	glEnable(GL_LIGHT0);

	// Enable colour tracking of materials
	glEnable(GL_COLOR_MATERIAL);

	// Define the shininess of the material we'll use to draw things
	GLfloat materialSpecularReflectance[] = { 1.0f, 1.0f, 1.0f, 1.0f };

	// Set Material properties to follow glColor values
	glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);

	// Use our shiny material and magnitude
	glMaterialfv(GL_FRONT, GL_SPECULAR, materialSpecularReflectance);
	glMateriali(GL_FRONT, GL_SHININESS, specularMagnitude);

	// Check for any OpenGL errors (providing the location we called the function from)
	checkGLError("InitGL");
	//printf("Size: %d",(sizeof(electron_arested)/sizeof(*electron_arested)));

	// ---------- Aqui vai
	//std::fill_n(electron_arested, (sizeof(electron_arested) / sizeof(*electron_arested)), -1);
	//GLint electron_arested[100][4][2]; // Primeiro eh o atomo e segundo o numero do electron
	for (int i = 0; i < 100; i++)
		for (int ii = 0; ii < 4; ii++)
			for (int iii = 0; iii < 4; iii++)
				electron_arested[i][ii][iii] = -1;

	last_x = 0 - 10.0;
	last_y = 0 - 10.0;
	srand((unsigned) time(0));
}

// Function to move the camera the amount we've calculated in the calculateCameraMovement function
void moveCamera() {
	camXPos += camXSpeed;
	camYPos += camYSpeed;
	camZPos += camZSpeed;
}

// Function to deal with mouse position changes, called whenever the mouse cursorm moves
void handleMouseMove(int mouseX, int mouseY) {
	GLfloat vertMouseSensitivity = 10.0f;
	GLfloat horizMouseSensitivity = 10.0f;

	//cout << "Mouse cursor is at position (" << mouseX << ", " << mouseY << endl;

	int horizMovement = mouseX - midWindowX;
	int vertMovement = mouseY - midWindowY;

	camXRot += vertMovement / vertMouseSensitivity;
	camYRot += horizMovement / horizMouseSensitivity;

	// Control looking up and down with the mouse forward/back movement
	// Limit loking up to vertically up
	if (camXRot < -90.0f) {
		camXRot = -90.0f;
	}

	// Limit looking down to vertically down
	if (camXRot > 90.0f) {
		camXRot = 90.0f;
	}

	// Looking left and right. Keep the angles in the range -180.0f (anticlockwise turn looking behind) to 180.0f (clockwise turn looking behind)
	if (camYRot < -180.0f) {
		camYRot += 360.0f;
	}

	if (camYRot > 180.0f) {
		camYRot -= 360.0f;
	}

	// Reset the mouse position to the centre of the window each frame
	glfwSetMousePos(midWindowX, midWindowY);
}

void calculaposicoes() {
	if (pressionando_k == true) {
		posx[0] = posx[0] + 0.1f;
		//printf("Aqui %f\n",posx);
	}

	if (pressionando_j == true) {
		posx[0] = posx[0] - 0.1f;
	}

	if (pressionando_i == true) {
		posy[0] = posy[0] + 0.1f;
	}

	if (pressionando_m == true) {
		posy[0] = posy[0] - 0.1f;
	}

	if (pressionando_o == true) {
		if (forca_x[0] > 0) {
			forca_x[0] -= 0.01f;
		}
	}

	if (pressionando_p == true) {
		if (forca_x[0] >= 0) {
			forca_x[0] += 0.01f;
		}
	}

	if (pressionando_0 == true) {
		forca_y[0] -= 3.0f;
		if (forca_y[0] < 0) {
			forca_y[0] = 359;
		}
	}

	if (pressionando_l == true) {
		forca_y[0] += 3.0f;
		if (forca_y[0] == 360) {
			forca_y[0] = 0;
		}
	}

	if (pressionando_8 == true) {
		forca_z[0] -= 10.0f;
		if (forca_z[0] < 0) {
			forca_z[0] = 359;
		}
	}

	if (pressionando_9 == true) {
		forca_z[0] += 10.0f;
		if (forca_z[0] == 360) {
			forca_z[0] = 0;
		}
	}
}

// Function to calculate which direction we need to move the camera and by what amount
void calculateCameraMovement() {
	// Break up our movement into components along the X, Y and Z axis
	float camMovementXComponent = 0.0f;
	float camMovementYComponent = 0.0f;
	float camMovementZComponent = 0.0f;

	if (holdingForward == true) {
		// Control X-Axis movement
		float pitchFactor = cos(toRads(camXRot));
		camMovementXComponent += (movementSpeedFactor * float(sin(toRads(camYRot)))) * pitchFactor;

		// Control Y-Axis movement
		camMovementYComponent += movementSpeedFactor * float(sin(toRads(camXRot))) * -1.0f;

		// Control Z-Axis movement
		float yawFactor = float(cos(toRads(camXRot)));
		camMovementZComponent += (movementSpeedFactor * float(cos(toRads(camYRot))) * -1.0f) * yawFactor;
	}

	if (holdingBackward == true) {
		// Control X-Axis movement
		float pitchFactor = cos(toRads(camXRot));
		camMovementXComponent += (movementSpeedFactor * float(sin(toRads(camYRot))) * -1.0f) * pitchFactor;

		// Control Y-Axis movement
		camMovementYComponent += movementSpeedFactor * float(sin(toRads(camXRot)));

		// Control Z-Axis movement
		float yawFactor = float(cos(toRads(camXRot)));
		camMovementZComponent += (movementSpeedFactor * float(cos(toRads(camYRot)))) * yawFactor;
	}

	if (holdingLeftStrafe == true) {
		// Calculate our Y-Axis rotation in radians once here because we use it twice
		float yRotRad = toRads(camYRot);

		camMovementXComponent += -movementSpeedFactor * float(cos(yRotRad));
		camMovementZComponent += -movementSpeedFactor * float(sin(yRotRad));
	}

	if (holdingRightStrafe == true) {
		// Calculate our Y-Axis rotation in radians once here because we use it twice
		float yRotRad = toRads(camYRot);

		camMovementXComponent += movementSpeedFactor * float(cos(yRotRad));
		camMovementZComponent += movementSpeedFactor * float(sin(yRotRad));
	}

	// After combining our movements for any & all keys pressed, assign them to our camera speed along the given axis
	camXSpeed = camMovementXComponent;
	camYSpeed = camMovementYComponent;
	camZSpeed = camMovementZComponent;

	// Cap the speeds to our movementSpeedFactor (otherwise going forward and strafing at an angle is twice as fast as just going forward!)
	// X Speed cap
	if (camXSpeed > movementSpeedFactor) {
		//cout << "high capping X speed to: " << movementSpeedFactor << endl;
		camXSpeed = movementSpeedFactor;
	}
	if (camXSpeed < -movementSpeedFactor) {
		//cout << "low capping X speed to: " << movementSpeedFactor << endl;
		camXSpeed = -movementSpeedFactor;
	}

	// Y Speed cap
	if (camYSpeed > movementSpeedFactor) {
		//cout << "low capping Y speed to: " << movementSpeedFactor << endl;
		camYSpeed = movementSpeedFactor;
	}
	if (camYSpeed < -movementSpeedFactor) {
		//cout << "high capping Y speed to: " << movementSpeedFactor << endl;
		camYSpeed = -movementSpeedFactor;
	}

	// Z Speed cap
	if (camZSpeed > movementSpeedFactor) {
		//cout << "high capping Z speed to: " << movementSpeedFactor << endl;
		camZSpeed = movementSpeedFactor;
	}
	if (camZSpeed < -movementSpeedFactor) {
		//cout << "low capping Z speed to: " << movementSpeedFactor << endl;
		camZSpeed = -movementSpeedFactor;
	}
}
void show_variables() {
//	printf("Variaveis1: forca_x: %f| forca_y: %f| electron_y: %f| posx: %f| posy: %f| posEx: %f| posEy: %f| posEz: %f\n", forca_x[0], forca_y[0], electron_y[0], posx[0], posy[0], posEx[0], posEy[0], posEz[0]);
//	printf("Variaveis2: forca_x: %f| forca_y: %f| electron_y: %f| posx: %f| posy: %f| posEx: %f| posEy: %f| posEz: %f\n", forca_x[1], forca_y[1], electron_y[1], posx[1], posy[1], posEx[1], posEy[1], posEz[1]);

	//printf("Variaveis1: posx: %f| posy: %f| posz: %f | forcay: %f | forcaz: %f | ElectronY: %f | ElectronZ: %f | Forcax: %f\n", posx[0], posy[0], posz[0], forca_y[0], forca_z[0], electron_y[0][0], electron_z[0][0], forca_x[0]);
	//printf("Variaveis2: posx: %f| posy: %f| posz: %f | forcay: %f | forcaz: %f | ElectronY: %f | ElectronZ: %f | Forcax: %f\n", posx[1], posy[1], posz[1], forca_y[1], forca_z[1], electron_y[1][0], electron_z[1][0], forca_x[1]);
	printf("if (atomos_quantidade == 0) {\n");
	printf("electron_y[0][0] = %f;\n", electron_y[0][0]);
	printf("electron_z[0][0] = %f;\n", electron_z[0][0]);
	printf("forca_x[0] = %f;\n", forca_x[0]);
	printf("forca_y[0] = %f;\n", forca_y[0]);
	printf("forca_z[0] = %f;\n", forca_z[0]);
	printf("posx[0] = %f;\n", posx[0]);
	printf("posy[0] = %f;\n", posy[0]);
	printf("posz[0] = %f;\n", posz[0]);

	printf("} else if (atomos_quantidade == 1) {\n");
	printf("electron_y[1][0] = %f;\n", electron_y[1][0]);
	printf("electron_z[1][0] = %f;\n", electron_z[1][0]);
	printf("forca_x[1] = %f;\n", forca_x[1]);
	printf("forca_y[1] = %f;\n", forca_y[1]);
	printf("forca_z[1] = %f;\n", forca_z[1]);
	printf("posx[1] = %f;\n", posx[1]);
	printf("posy[1] = %f;\n", posy[1]);
	printf("posz[1] = %f;\n", posz[1]);
	printf("}\n");
}

void ativa_desativa_rastreio() {
	if (rastreio) {
		rastreio = false;
	} else {
		rastreio = true;
	}
}

void ativa_desativa_forca() {
	if (show_power_sphere) {
		show_power_sphere = false;
	} else {
		show_power_sphere = true;
	}
}

void camera_position(GLfloat px, GLfloat py, GLfloat pz, GLfloat rx, GLfloat ry, GLfloat rz) {
	camXRot = rx;
	camYRot = ry;
	camZRot = rz;

	camXPos = px;
	camYPos = py;
	camZPos = pz + 10;
}

void add_energy() {
	for (GLint i = 0; i < atomos_quantidade; i++) {
		forca_x[i] += 0.1;
	}
}

void rem_energy() {
	for (GLint i = 0; i < atomos_quantidade; i++) {
		if (forca_x[i] >= 0.1) {
			forca_x[i] -= 0.1;
		}
	}
}

void add_atom() {
	tensao[atomos_quantidade] = 0.2;
	tensao_giro[atomos_quantidade] = 5.0;
	electron_quantidade[atomos_quantidade] = 1;
	nucleo_proximity[atomos_quantidade] = 2.0;
	nucleo_proximity_free[atomos_quantidade] = 3.0;
	electron_y[atomos_quantidade][0] = 0.0;
	electron_z[atomos_quantidade][0] = 0.0;
	electron_raio[atomos_quantidade] = 6.0;

//	Variaveis1: posx: 7.428084| posy: 9.726863| posz: 5.201216 | forcay: 340.000000 | forcaz: 35.000000
//	Variaveis2: posx: 11.547237| posy: 10.158332| posz: 5.955782 | forcay: 340.000000 | forcaz: 35.000000
//	if (atomos_quantidade == 0) {
//		electron_y[atomos_quantidade][0] = 0.0;

	if (last_x > caixa_tamanho - 5.0) {
		last_x = 0 - caixa_tamanho + 2;
		last_y += 15.0;
	}
	if (atomos_quantidade == 0) {
		last_x = 0.0;
		last_y = 0.0;
	}
	// Colocar devolta
	posx[atomos_quantidade] = last_x;
	posy[atomos_quantidade] = last_y;
	posz[atomos_quantidade] = 0.0;
	forca_x[atomos_quantidade] = 0.0;
	forca_y[atomos_quantidade] = 0.0;
	forca_z[atomos_quantidade] = 0.0;

	//Variaveis1: posx: 8.599997| posy: 0.000000| posz: 11.500000 | forcay: 10.000000 | forcaz: 0.000000 | ElectronY: 0.000000 | ElectronZ: 276.941010
	//Variaveis2: posx: 10.000000| posy: 0.000000| posz: 0.000000 | forcay: 170.000000 | forcaz: 0.000000 | ElectronY: 180.000000 | ElectronZ: 276.940979
	// Teste 1
	if (atomos_quantidade == 0) {
		electron_y[atomos_quantidade][0] = 350.0;
		electron_z[atomos_quantidade][0] = 90.0;
		forca_x[atomos_quantidade] = 0.1;
		forca_y[atomos_quantidade] = 0.0;
		forca_z[atomos_quantidade] = 270.0;
		posx[atomos_quantidade] = 0.0;
		posy[atomos_quantidade] = 0.0;
		posz[atomos_quantidade] = 0.0;
	} else if (atomos_quantidade == 1) {
		electron_y[atomos_quantidade][0] = 0.0;
		electron_z[atomos_quantidade][0] = 270.0;
		forca_x[atomos_quantidade] = 0.1;
		forca_y[atomos_quantidade] = 0.0;
		forca_z[atomos_quantidade] = 90.0;
		posx[atomos_quantidade] = 0.0;
		posy[atomos_quantidade] = 0.0;
		posz[atomos_quantidade] = 10.0;
	}

//	teste 2
//	if (atomos_quantidade == 0) {
//		electron_y[atomos_quantidade][0] = 330.0;
//		electron_z[atomos_quantidade][0] = 45.0;
//		forca_x[atomos_quantidade] = 0.05;
//		forca_y[atomos_quantidade] = 30.0;
//		forca_z[atomos_quantidade] = 270.0;
//		posx[atomos_quantidade] = -6.6;
//		posy[atomos_quantidade] = 6.6;
//		posz[atomos_quantidade] = 0.5;
//	} else if (atomos_quantidade == 1) {
//		electron_y[atomos_quantidade][0] = 35.0;
//		electron_z[atomos_quantidade][0] = 232.0;
//		forca_x[atomos_quantidade] = 0.0;
//		forca_y[atomos_quantidade] = 0.0;
//		forca_z[atomos_quantidade] = 90.0;
//		posx[atomos_quantidade] = 0.0;
//		posy[atomos_quantidade] = 0.0;
//		posz[atomos_quantidade] = 8.0;
//	}

// teste 3
//	if (atomos_quantidade == 0) {
//		electron_y[0][0] = 330.000000;
//		electron_z[0][0] = 45.000000;
//		forca_x[0] = 0.020000;
//		forca_y[0] = 30.000000;
//		forca_z[0] = 210.000000;
//		posx[0] = -9.179984;
//		posy[0] = 8.370040;
//		posz[0] = -1.076164;
//	} else if (atomos_quantidade == 1) {
//		electron_y[1][0] = 35.000000;
//		electron_z[1][0] = 232.000000;
//		forca_x[1] = 0.000000;
//		forca_y[1] = 355.000000;
//		forca_z[1] = 215.000000;
//		posx[1] = -3.348509;
//		posy[1] = 2.237846;
//		posz[1] = 6.239244;
//	}

	// teste 4
//	if (atomos_quantidade == 0) {
//		electron_y[0][0] = 350.000000;
//		electron_z[0][0] = 90.000000;
//		forca_x[0] = 0.000000;
//		forca_y[0] = 205.000000;
//		forca_z[0] = 90.000000;
//		posx[0] = 0.286498;
//		posy[0] = 0.938679;
//		posz[0] = 2.067036;
//	} else if (atomos_quantidade == 1) {
//		electron_y[1][0] = 0.000000;
//		electron_z[1][0] = 270.000000;
//		forca_x[1] = 0.100000;
//		forca_y[1] = 185.000000;
//		forca_z[1] = 265.000000;
//		posx[1] = 0.253527;
//		posy[1] = -0.254495;
//		posz[1] = 12.897789;
//	}

	electron_arested[0][0][0] = 1;
	electron_arested[0][0][1] = 0;
	electron_arested[1][0][0] = 0;
	electron_arested[1][0][1] = 0;

//		posx[atomos_quantidade] = 10.0;
//		posy[atomos_quantidade] = 0.0;
//		posz[atomos_quantidade] = 0.0;
//	}

//	} else if (atomos_quantidade == 1) {
////		electron_y[atomos_quantidade][0] = 180.0;
//		forca_x[atomos_quantidade] = 0.5;
//		forca_y[atomos_quantidade] = 180.0;
//		forca_z[atomos_quantidade] = 0.0;
//		posx[atomos_quantidade] = 0.0;
//		posy[atomos_quantidade] = 0.0;
//		posz[atomos_quantidade] = 0.0;
//	} else {
//		forca_x[atomos_quantidade] = 0.5;
//		forca_y[atomos_quantidade] = 180.0;
//		forca_z[atomos_quantidade] = 0.0;
//		posx[atomos_quantidade] = 12.0;
//		posy[atomos_quantidade] = 0.0;
//		posz[atomos_quantidade] = 0.0;
//	}

	posEx[atomos_quantidade][0] = 0.0;
	posEy[atomos_quantidade][0] = 0.0;
	posEz[atomos_quantidade][0] = 0.0;
	if (electron_quantidade[atomos_quantidade] >= 2) {
//		electron_y[atomos_quantidade][1] = 90.0;
		posEx[atomos_quantidade][1] = 0.0;
		posEy[atomos_quantidade][1] = 0.0;
		posEz[atomos_quantidade][1] = 0.0;
	}
	if (electron_quantidade[atomos_quantidade] >= 3) {
//		electron_y[atomos_quantidade][2] = 180.0;
		posEx[atomos_quantidade][2] = 0.0;
		posEy[atomos_quantidade][2] = 0.0;
		posEz[atomos_quantidade][2] = 0.0;
	}
	if (electron_quantidade[atomos_quantidade] >= 4) {
//		electron_y[atomos_quantidade][3] = 270.0;
		posEx[atomos_quantidade][3] = 0.0;
		posEy[atomos_quantidade][3] = 0.0;
		posEz[atomos_quantidade][3] = 0.0;
	}
	printf("Atomo: %d\n", atomos_quantidade);
	atomos_quantidade++;
	last_x += 10.0;
}
// Function to set flags according to which keys are pressed or released
void handleKeypress(int theKey, int theAction) {
	// If a key is pressed, toggle the relevant key-press flag
	if (theAction == GLFW_PRESS) {

		switch (theKey) {
		case 'W':
			holdingForward = true;
			break;

		case 'S':
			holdingBackward = true;
			break;

		case 'A':
			holdingLeftStrafe = true;
			break;

		case 'D':
			holdingRightStrafe = true;
			break;

		case 'K':
			pressionando_k = true;
			break;

		case 'J':
			pressionando_j = true;
			break;

		case 'I':
			pressionando_i = true;
			break;

		case 'M':
			pressionando_m = true;
			break;

		case 'Y':
			posz[0] -= 0.5;
			break;

		case 'H':
			posz[0] += 0.5;
			break;

		case 'O':
			pressionando_o = true;
			break;

		case 'P':
			pressionando_p = true;
			break;

		case '0':
			pressionando_0 = true;
			break;

		case 'L':
			pressionando_l = true;
			break;

		case '8':
			pressionando_8 = true;
			break;

		case '9':
			pressionando_9 = true;
			break;

		case 'B':
			show_variables();
			break;

		case 'G':
			add_atom();
			break;

		case '1':
			camera_position(0.0, 0.0, caixa_tamanho, 0.0, 0.0, 0.0);
			break;

		case '2':
			camera_position(caixa_tamanho * 6.0, 0.0, -90.0, 0.0, -90.0, 0.0);
			break;

		case '3':
			camera_position(0.0, caixa_tamanho * 6.0, -90.0, 90.0, 180.0, -90.0);
			break;

		case '4':
			camera_position(caixa_tamanho * 3.0, caixa_tamanho * 3.0, caixa_tamanho, 27.0, -30.0, 0.0);
			break;

		case 'R':
			ativa_desativa_rastreio();
			break;

		case 'F':
			ativa_desativa_forca();
			break;

		case 'Z':
			rem_energy();
			break;

		case 'X':
			add_energy();
			break;

		default:
			// Do nothing...
			break;
		}
	} else // If a key is released, toggle the relevant key-release flag
	{
		switch (theKey) {
		case 'W':
			holdingForward = false;
			break;

		case 'S':
			holdingBackward = false;
			break;

		case 'A':
			holdingLeftStrafe = false;
			break;

		case 'D':
			holdingRightStrafe = false;
			break;

		case 'K':
			pressionando_k = false;
			break;

		case 'J':
			pressionando_j = false;
			break;

		case 'I':
			pressionando_i = false;
			break;

		case 'M':
			pressionando_m = false;
			break;

		case 'O':
			pressionando_o = false;
			break;

		case 'P':
			pressionando_p = false;
			break;

		case '0':
			pressionando_0 = false;
			break;

		case 'L':
			pressionando_l = false;
			break;

		case '8':
			pressionando_8 = false;
			break;

		case '9':
			pressionando_9 = false;
			break;

		default:
			// Do nothing...
			break;
		}
	}
}

// Function to draw a grid of lines
void drawGround() {
	GLfloat extent = 600.0f; // How far on the Z-Axis and X-Axis the ground extends
	GLfloat stepSize = 50.0f;  // The size of the separation between points
	GLfloat groundLevel = -50.0f;   // Where on the Y-Axis the ground is drawn

	// Set colour to white
	glColor3ub(255, 255, 255);

	// Draw our ground grid
	glBegin(GL_LINES);
	for (GLint loop = -extent; loop < extent; loop += stepSize) {
		// Draw lines along Z-Axis
		glVertex3f(loop, groundLevel, extent);
		glVertex3f(loop, groundLevel, -extent);

		// Draw lines across X-Axis
		glVertex3f(-extent, groundLevel, loop);
		glVertex3f(extent, groundLevel, loop);
	}
	glEnd();
}

//struct Angle_Power {
//	GLfloat vetor_1;
//	GLfloat forca_1;
//	GLfloat vetor_2;
//	GLfloat forca_2;
//};
//void angle_power(GLfloat aa, GLfloat bb, GLfloat cc, GLfloat dd) {
//void angle_power() {
//Angle_Power angle_power(GLfloat vetor_1, GLfloat forca_1, GLfloat vetor_2, GLfloat forca_2) {
void hitting_wall(GLfloat *vetor_Y, GLfloat *vetor_Z, string parede) {
	if (parede == "teto") {
		(*vetor_Y) = 360.0 - (*vetor_Y);
	} else if (parede == "chao") {
		(*vetor_Y) = 360.0 - (*vetor_Y);
	} else if (parede == "direita") {
		(*vetor_Y) = 180.0 - (*vetor_Y);
		(*vetor_Z) = 360.0 - (*vetor_Z);
	} else if (parede == "esquerda") {
		(*vetor_Y) = 180.0 - (*vetor_Y);
		(*vetor_Z) = 360.0 - (*vetor_Z);
	} else if (parede == "fundo") {
		(*vetor_Z) = 180.0 - (*vetor_Z);
		(*vetor_Y) = 180.0 - (*vetor_Y);
	} else if (parede == "frente") {
		(*vetor_Z) = 180.0 - (*vetor_Z);
		(*vetor_Y) = 180.0 - (*vetor_Y);
	}
	if ((*vetor_Y) >= 360) {
		(*vetor_Y) -= 360;
	}
	if ((*vetor_Z) >= 360) {
		(*vetor_Z) -= 360;
	}
}

//void power_direcao(GLint atomoA, GLint atomoB) {
//	printf("A1y: %f A2y: %f\n");
//}

void angle_power2(GLfloat *vetor_Y, GLfloat *vetor_Z, GLfloat *forca_X, GLfloat *vetor_Y2, GLfloat *vetor_Z2, GLfloat *forca_X2) {
//	printf("1) Y:%f/%f  Z:%f/%f\n", (*vetor_Y), (*vetor_Y2), (*vetor_Z), (*vetor_Z2));
	GLfloat diference = (*vetor_Y2) - (*vetor_Y);
	GLfloat diferenceZ = (*vetor_Z2) - (*vetor_Z);

	(*vetor_Y2) = (*vetor_Y2) - diference;
	(*vetor_Y) = (*vetor_Y) + diference;

	(*vetor_Z2) = (*vetor_Z2) - diferenceZ;
	(*vetor_Z) = (*vetor_Z) + diferenceZ;

	GLfloat powert = (*forca_X);
	(*forca_X) = (*forca_X2);
	(*forca_X2) = powert;
//	printf("2) Y:%f/%f  Z:%f/%f\n", (*vetor_Y), (*vetor_Y2), (*vetor_Z), (*vetor_Z2));
}

//void angle_power(GLfloat *vetor_Y, GLfloat *forca_1, GLfloat *vetor_Z, GLfloat *vetor_Y2, GLfloat *vetor_Z2, GLfloat *forca_2, GLfloat *pos) {
//	// ------------------ Funcionando com paredes, colisao horizontal e vertical
//	printf("Angle Power 1 !!!!\n");
//	GLfloat diference = (*vetor_Y2) - (*vetor_Y);
//	GLfloat diferenceZ = (*vetor_Z2) - (*vetor_Z);
//
//	(*vetor_Y2) = (*vetor_Y2) - diference;
//	(*vetor_Y) = (*vetor_Y) + diference;
//	GLfloat powert = (*forca_1);
//	(*forca_1) = (*forca_2);
//	(*forca_2) = powert;
//
//}

GLfloat show_distance2(GLfloat x1, GLfloat x2, GLfloat y1, GLfloat y2, GLfloat z1, GLfloat z2) {
	return sqrt(pow((x2 - x1), 2.0) + pow((y2 - y1), 2.0) + pow((z2 - z1), 2.0));
}

bool angle_colision(GLint atomo1, GLint electron1, GLint atomo2, GLint electron2) {
	GLfloat d_atomo_atomo = show_distance2(posx[atomo1], posx[atomo2], posy[atomo1], posy[atomo2], posz[atomo1], posz[atomo2]);
	GLfloat atomo_electron = electron_raio[atomo1] + electron_raio[atomo2];
	if (abs(d_atomo_atomo - atomo_electron) < 0.1) {
		return true;
	}
	return false;
}

//GLfloat show_distance(GLfloat x1, GLfloat x2, GLfloat y1, GLfloat y2) {
//	return sqrt(pow((x2 - x1), 2.0) + pow((y2 - y1), 2.0));
//return pow(2.0,2.0);
//return fabs(first, second);
//printf("Valor %f\n",fabs(10.0, 8.0));
//	if(first < second){
//		return second - first;
//	} else {
//		return first - second;
//	}
//return 0.0;

//}

bool checa_between(GLfloat numero, GLfloat comeco, GLfloat fim, GLfloat tensao) {
	if (comeco <= fim) {
		if (numero >= comeco && numero <= fim) {
			return true;
		} else {
			if (numero > fim && numero - fim <= tensao) {
				return true;
			} else if (numero < comeco && comeco - numero <= tensao) {
				return true;
			}
		}
	} else {
		if (numero >= fim && numero <= comeco) {
			return true;
		} else {
			if (numero > comeco && numero - comeco <= tensao) {
				return true;
			} else if (numero < fim && fim - numero <= tensao) {
				return true;
			}
		}
	}
	return false;
}

void drawP(GLfloat oy, GLfloat oz, GLfloat ox) {
	GLfloat cosseno = cos(toRads(oy)) * ox * 3.5;
	GLfloat seno = sin(toRads(oy)) * ox * 3.5;
	GLfloat cossenoZ = cos(toRads(oz)) * cosseno;
	GLfloat senoZ = sin(toRads(oz)) * cosseno;
	glColor3ub(255, 255, 0);
	glTranslatef(cossenoZ, seno, senoZ);
	glutSolidSphere(1.5f, 6, 6);
	glTranslatef(-cossenoZ, -seno, -senoZ);
}

void drawE(GLfloat oy, GLfloat oz, GLfloat ox, GLint atomN, GLint electronN) {
	GLfloat cosseno = cos(toRads(oy)) * ox;
	GLfloat seno = sin(toRads(oy)) * ox;
	GLfloat cossenoZ = cos(toRads(oz)) * cosseno;
	GLfloat senoZ = sin(toRads(oz)) * cosseno;
//	glColor3ub(255, 255, 0);
	glTranslatef(cossenoZ, seno, senoZ);
//	printf("Atom: %f  E: %f  R:%f \n", posx[atomN], cossenoZ, (posx[atomN] + cossenoZ));
	posEx[atomN][electronN] = posx[atomN] + cossenoZ;
	posEy[atomN][electronN] = posy[atomN] + seno;
	posEz[atomN][electronN] = posz[atomN] + senoZ;
	glutSolidSphere(0.2f, 6, 6);
	glTranslatef(-cossenoZ, -seno, -senoZ);
}

// Function to draw our spheres and position the light source
void drawScene() {
	// Clear the screen and depth buffer
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	// Reset the matrix
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	// Move the camera to our location in space
	glRotatef(camXRot, 1.0f, 0.0f, 0.0f); // Rotate our camera on the x-axis (looking up and down)
	glRotatef(camYRot, 0.0f, 1.0f, 0.0f); // Rotate our camera on the  y-axis (looking left and right)
	glTranslatef(-camXPos, -camYPos, -camZPos); // Translate the modelviewm matrix to the position of our camera
	// Move everything "into" the screen (i.e. move 300 units along the Z-axis into the screen) so that all positions are now relative to the location of the sun
	glTranslatef(0.0f, 0.0f, sunZLocation);
	glColor3ub(255, 255, 0);
	glutWireCube(2.0 * caixa_tamanho);

	for (GLint i = 0; i < atomos_quantidade; i++) {
		if (posy[i] > caixa_tamanho) {
			hitting_wall(&forca_y[i], &forca_z[i], "teto");
		} else if (posy[i] < caixa_tamanho * -1) {
			hitting_wall(&forca_y[i], &forca_z[i], "chao");
		}
		if (posx[i] > caixa_tamanho) {
			hitting_wall(&forca_y[i], &forca_z[i], "direita");
		} else if (posx[i] < caixa_tamanho * -1) {
			hitting_wall(&forca_y[i], &forca_z[i], "esquerda");
		}
		if (posz[i] > caixa_tamanho) {
			hitting_wall(&forca_y[i], &forca_z[i], "frente");
		} else if (posz[i] < caixa_tamanho * -1) {
			hitting_wall(&forca_y[i], &forca_z[i], "fundo");
		}
		// ===================== Forca ======================
		GLfloat cosseno = cos(toRads(forca_y[i])) * forca_x[i] * 0.1;
		GLfloat seno = sin(toRads(forca_y[i])) * forca_x[i] * 0.1;
		GLfloat cossenoZ = cos(toRads(forca_z[i])) * cosseno;
		GLfloat senoZ = sin(toRads(forca_z[i])) * cosseno;
		posx[i] += cossenoZ;
		posy[i] += seno;
		posz[i] += senoZ;

//		posx[i] += cos(toRads(forca_y[i])) * forca_x[i] * 0.1;
//		posy[i] += sin(toRads(forca_y[i])) * forca_x[i] * 0.1;
//		posz[i] += sin(toRads(forca_z[i])) * forca_x[i] * 0.1;
		// ===================== Nucleo ======================
		if (i == 0) {
			glColor3ub(50, 255, 255);
		} else if (i == 1) {
			glColor3ub(240, 100, 50);
		} else if (i == 2) {
			glColor3ub(120, 10, 150);
		} else if (i == 3) {
			glColor3ub(80, 120, 100);
		} else if (i == 4) {
			glColor3ub(66, 97, 144);
		} else if (i == 5) {
			glColor3ub(187, 100, 55);
		} else {
			glColor3ub(200, 67, 55);
		}
		glTranslatef(posx[i], posy[i], posz[i]);
		glutSolidSphere(1.5f, 30, 30);

		if (rastreio) {
			// Linha teto
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, caixa_tamanho - posy[i], 0.0);
			glEnd();

			// Linha chao
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, -caixa_tamanho - posy[i], 0.0);
			glEnd();

			// Linha direita
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(caixa_tamanho - posx[i], 0.0, 0.0);
			glEnd();

			// Linha esquerda
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(-caixa_tamanho - posx[i], 0.0, 0.0);
			glEnd();

			// Linha frente
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, 0.0, caixa_tamanho - posz[i]);
			glEnd();

			// Linha fundo
			glBegin(GL_LINES);
			glVertex3f(0.0, 0.0, 0.0);
			glVertex3f(0.0, 0.0, -caixa_tamanho - posz[i]);
			glEnd();
		}
		// ===================== Esfera Forca ======================

		if (show_power_sphere) {
			drawP(forca_y[i], forca_z[i], forca_x[i]);
		}

		// ===================== Esfera Electron ======================
		for (GLint Es = 0; Es < electron_quantidade[i]; Es++) {
			cosseno = 0; // (X)
			seno = 0; // (Y)

			if (cont_loop_electron == cont_loop_electron_time && electron_arested[i][Es][0] == -1) {
				GLfloat resultado_l = 0;
				GLfloat resultado_l2 = 0;
				nSeed = (8253729 * nSeed + 2396403);
				resultado_l = nSeed % 359;
				nSeed = (8253729 * nSeed + 2396403);
				resultado_l2 = nSeed % 359;
				bool segue = false;
				while (!segue) {
					segue = true;
					for (GLint conte = 0; conte < electron_quantidade[i]; conte++) {
						if (conte != Es) {
							//printf("N: %d | Res: %f | E: %f\n", conte, resultado_l, electron_y[i][conte]);
							if (fabs(electron_y[i][conte] - resultado_l) > 180) {
								if (360 - fabs(electron_y[i][conte] - resultado_l) < 20.0) {
									//printf(">180 %f | %f | %f\n", 360 - fabs(electron_y[i][conte] - resultado_l), electron_y[i][conte], resultado_l);
									segue = false;
									nSeed = (8253729 * nSeed + 2396403);
									resultado_l = nSeed % 359;
									conte = 0;
									//printf("Muito perto %d\n", i);
								}
							} else if (fabs(electron_y[i][conte] - resultado_l) < 20.0) {
								//printf("< 180 %f\n", fabs(electron_y[i][conte] - resultado_l));
								segue = false;
								nSeed = (8253729 * nSeed + 2396403);
								resultado_l = nSeed % 359;
								conte = 0;
								//printf("Muito perto %d\n", i);
							}
						}
					}
				}

				//printf("0.2) a:%f  b:%f  c:%f  \n", electron_y[i][0], electron_y[i][1], electron_y[i][2]);
//				electron_y[i][Es] = resultado_l;
//				electron_z[i][Es] = resultado_l2;
			}
			cosseno = cos(toRads(electron_y[i][Es])) * 6.0;
			seno = sin(toRads(electron_y[i][Es])) * 6.0;
			if (electron_arested[i][Es][0] != -1 && electron_arested[electron_arested[i][Es][0]][electron_arested[i][Es][1]][0] != i && electron_arested[electron_arested[i][Es][0]][electron_arested[i][Es][1]][1] != Es) {
				electron_arested[i][Es][0] = -1;
			}
			if (electron_arested[i][Es][0] == -1) {
				glColor3ub(255, 0, 0);
			} else {
				glColor3ub(255, 200, 100);
			}
			//glTranslatef(cosseno, seno, posz[i]);
//			glTranslatef(cosseno, seno, 0.0);
//			glutSolidSphere(0.2f, 6, 6);
//			posEx[i][Es] = cosseno + posx[i];
//			posEy[i][Es] = seno + posy[i];
//			glTranslatef(-cosseno, -seno, posz[i]);

//			printf("Dist: %f %f %f\n", posx[i], posEx[0][0], show_distance2(posx[i], posEx[0][0], posy[i], posEy[0][0], posz[i], posEz[0][0]));
//			if (electron_arested[i][Es][0] != -1 && i < electron_arested[i][Es][0]) {
			if (electron_arested[i][Es][0] != -1) {
				glColor3ub(255, 255, 255);
				glBegin(GL_LINES);
				glVertex3f(0.0, 0.0, 0.0);
				GLfloat difx = 0.0;
				GLfloat dify = 0.0;
				GLfloat difz = 0.0;

				GLfloat difxE = 0.0;
				GLfloat difyE = 0.0;
				GLfloat difzE = 0.0;
				GLfloat distancef = show_distance2(posx[i], posx[electron_arested[i][Es][0]], posy[i], posy[electron_arested[i][Es][0]], posz[i], posz[electron_arested[i][Es][0]]);
				if (posx[i] > posx[electron_arested[i][Es][0]]) {
					difx = 0 - show_distance2(posx[i], posx[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difxE = electron_raio[i] * difx / distancef;
				} else {
					difx = show_distance2(posx[i], posx[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difxE = electron_raio[i] * difx / distancef;
				}
				if (posy[i] > posy[electron_arested[i][Es][0]]) {
					dify = 0 - show_distance2(posy[i], posy[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difyE = electron_raio[i] * dify / distancef;
//					printf("Distance %f R %f  Posy %f Posy2 %f dify %f\n",distancef, electron_raio[i],posy[i],posy[electron_arested[i][Es][0]],dify);
				} else {
					dify = show_distance2(posy[i], posy[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difyE = electron_raio[i] * dify / distancef;
//					printf("A2\n");
				}
				if (posz[i] > posz[electron_arested[i][Es][0]]) {
					difz = 0 - show_distance2(posz[i], posz[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difzE = electron_raio[i] * difz / distancef;
				} else {
					difz = show_distance2(posz[i], posz[electron_arested[i][Es][0]], 0.0, 0.0, 0.0, 0.0);
					difzE = electron_raio[i] * difz / distancef;
				}
				glVertex3f(difx, dify, difz);
				glEnd();
//				if (i == 0) {
				if (difxE != difxE) {
					difxE = 0.0;
				}
				if (difyE != difyE) {
					difyE = 0.0;
				}
				if (difzE != difzE) {
					difzE = 0.0;
				}
//				printf("R: X %f %f   Y %f %f    Z %f %f (%f|%f)\n", difx, difxE, dify, difyE, difz, difzE, posy[i], posy[electron_arested[i][Es][0]]);
				glTranslatef(difxE, difyE, difzE);
				glutSolidSphere(0.2f, 6, 6);
				glTranslatef(-difxE, -difyE, -difzE);
				posEx[i][Es] = posx[i] + difxE;
				posEy[i][Es] = posy[i] + difyE;
				posEz[i][Es] = posz[i] + difzE;
			} else {
//				printf("De qualquer forma\n");
				drawE(electron_y[i][Es], electron_z[i][Es], electron_raio[i], i, Es);
			}

		}

// ================ Checa colisao de nucleo ================
		GLfloat compare = 0.0;
		GLfloat compare2 = 0.0;
		for (GLint ii = 0; ii < atomos_quantidade; ii++) {
			if (i != ii) {
				GLfloat distance_to_compare = nucleo_proximity_free[i];
				for (GLint ei = 0; ei < atomos_quantidade; ei++) {
					if (electron_arested[i][ei][0] == ii) {
						//printf("Estavam conectados\n");
						distance_to_compare = nucleo_proximity[i];
						//was_arested = true;
					}
				}
				//printf("Distancia: %f \n", show_distance2(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]));
				if (show_distance2(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]) <= distance_to_compare) {
					//angle_power(&forca_y[i], &forca_x[i], &forca_z[i], &forca_y[ii], &forca_z[ii], &forca_x[ii], &posx[i]);
//					printf("Col: %d %d\n", i, ii);
					angle_power2(&forca_y[i], &forca_z[i], &forca_x[i], &forca_y[ii], &forca_z[ii], &forca_x[ii]);
					if (posy[i] > posy[ii]) {
						posy[i] += 0.01;
						posy[ii] -= 0.01;
					} else {
						posy[i] -= 0.01;
						posy[ii] += 0.01;
					}
				}
				//printf("Distancia: %fg \n",fabs(10.0-3.0));
//				compare = fabs(posx[i] - posx[ii]);
				//printf("Muito proximo %f Compare:%f i:%f ii:%f\n",distance_to_compare, compare, posx[i], posx[ii]);
//				if (compare <= distance_to_compare) {
//					compare = fabs(posy[i] - posy[ii]);
//					if (compare <= distance_to_compare) {

				//bool was_arested = false;

//						if (!was_arested) {
////						printf("NAO Estavam conectados\n");
//							angle_power(&forca_y[i], &forca_x[i], &forca_y[ii], &forca_x[ii], &posx[i]);
//							if (posy[i] > posy[ii]) {
//								posy[i] += 0.01;
//								posy[ii] -= 0.01;
//							} else {
//								posy[i] -= 0.01;
//								posy[ii] += 0.01;
//							}
//						}
//					}
//				}
			}
		}
		//printf("3) c:%f  \n", electron_y[0][2]);

		//printf("4) a:%f  b:%f  c:%f  \n", electron_y[0][0], electron_y[0][1], electron_y[0][2]);
// ================ Checa colisao de electron ================
		compare = 0.0;
		bool isclose = false;
//		printf("Pos 1)%f   2)%f\n", posx[0],posx[1]);
		for (GLint Es = 0; Es < electron_quantidade[i]; Es++) {
			for (GLint ii = 0; ii < atomos_quantidade; ii++) {
				if (i != ii) {
					//					break;

					for (GLint Es2 = 0; Es2 < electron_quantidade[i]; Es2++) {
						//						compare = fabs(posEx[i][Es] - posEx[ii][Es2]);
						//						if (compare <= collision_proximityE) {
						////						printf("AE0.2\n");
						//							compare = fabs(posEy[i][Es] - posEy[ii][Es2]);
						//							if (compare <= collision_proximityE) {
						//						if (show_distance(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2]) <= collision_proximityE) {
//						printf("AE0.3 E1:%f  E2:%f  D:%f Dmin:%f\n", posEx[i][Es], posEx[ii][Es2], show_distance2(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2], posEz[i][Es], posEz[ii][Es2]), collision_proximityE);

						if (show_distance2(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2], posEz[i][Es], posEz[ii][Es2]) <= collision_proximityE) {
							isclose = true;
//							printf("Perto\n");
//							angle_colision(i,Es,ii,Es2);
//							printf("AE0.3.1 %f %f\n", show_distance2(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2], posEz[i][Es], posEz[ii][Es2]), collision_proximityE);
//							if (fabs(180 - fabs(electron_y[i][Es] - electron_y[ii][Es2])) <= angle_proximity) {
							if (angle_colision(i, Es, ii, Es2)) {
								//								 printf("electron_y[i]: %f    electron_y[ii]: %f (%d)\n",electron_y[i][Es], electron_y[ii][Es2], angle_proximity);
								////								// --------- Nessa me perdi no i, precisa melhora
								if (electron_arested[ii][Es2][0] != -1 && electron_arested[ii][Es2][0] != i && electron_arested[ii][Es2][1] != Es) {
									//									printf("Tentando terceiro\n");
								} else if (electron_arested[i][Es][0] == -1) {
									printf("Alterando electron\n");
									electron_arested[i][Es][0] = ii;
									electron_arested[i][Es][1] = Es2;
									electron_arested[ii][Es2][0] = i;
									electron_arested[ii][Es2][1] = Es;
									//electron_y[i][Es] = fixNegativeAngle(toAngle(atan2(-(posy[i]) + posy[ii], -(posx[i]) + posx[ii])));
									//electron_y[ii][Es2] = fixNegativeAngle(toAngle(atan2(-(posy[ii]) + posy[i], -(posx[ii]) + posx[i])));

//									GLfloat cosseno = cos(toRads(oy)) * ox;
//									GLfloat seno = sin(toRads(oy)) * ox;
//									GLfloat cossenoZ = cos(toRads(oz)) * cosseno;
//									GLfloat senoZ = sin(toRads(oz)) * cosseno;
//									glTranslatef(cossenoZ, seno, senoZ);
//									GLfloat novoZ = fixNegativeAngle(toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii])));
//									printf("Novoz: %f\n",novoZ);
//									GLfloat novoZ = 0.0;

//									if (novoZ > 90.0 && novoZ < 270) {
////										printf("Aqui\n");
//										novoZ = 360 - (180 - novoZ);
//									}
//									else {
//
//									}
//									if(posx[i] < posx[ii]){
//										novoZ = (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii])));
//									} else {
//										novoZ = 360 - (180 -(toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii]))));
//									}
//									printf("A: %f  %f\n",electron_z[i][Es],electron_z[ii][Es2]);
//									if(electron_z[i][Es] > electron_z[ii][Es2]){
//										novoZ = 180.0 - electron_z[i][Es];
//										printf("C: %f %f\n", novoZ, (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii]))));
//									}

//									if (i == 0) {
//										printf("Angulo: %f\n", fixNegativeAngle(toAngle(atan2(-(posy[i]) + posy[ii], -(posx[i]) + posx[ii]))));
//										novoZ = (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii])));
//										printf("Z1: %f\n",novoZ);
////										printf("Z(%f|%f)   ZA1: %f     ZA2: %f   R:%f \n", posz[0], posz[1], electron_z[i][Es], electron_z[ii][Es2], (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii]))));
////										electron_z[i][Es] = (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii])));
//									} else {
//										printf("Z2: %f\n",novoZ);
//										//printf("Z(%f|%f)   ZA1: %f     ZA2: %f   R:%f \n", posz[0], posz[1], electron_z[i][Es], electron_z[ii][Es2], (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii]))));
//										novoZ = 360 - (180 -(toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii]))));
//										printf("Z2: %f %f\n",novoZ, (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii]))));
////										electron_z[i][Es] = (toAngle(atan2(-(posz[i]) + posz[ii], -(posx[i]) + posx[ii])));
//									}
//									electron_z[i][Es] = fixNegativeAngle(novoZ);
//									electron_z[i][Es] = fixNegativeAngle(toAngle(atan2(-(posz[i]) + posy[ii], -(posx[i]) + posx[ii])));
//									electron_z[ii][Es] = fixNegativeAngle(toAngle(atan2(-(posz[ii]) + posy[i], -(posx[ii]) + posx[i])));
//									electron_y[ii][Es2] = fixNegativeAngle(toAngle(atan2(-(posy[ii]) + posy[i], -(posx[ii]) + posx[i])));
									/*
									 if (fabs(forca_y[i] - electron_y[i][Es]) <= 180) {
									 //											printf("< 180 %d\n", i);
									 if (forca_y[i] > electron_y[i][Es]) {
									 //												printf("A %f\n", forca_y[i]);
									 forca_y[i] -= electron_power;
									 } else if (forca_y[i] < electron_y[i][Es]) {
									 //												printf("B %f\n", forca_y[i]);
									 forca_y[i] += electron_power;
									 }
									 } else {
									 //											printf("> 180 %d\n", i);
									 if (forca_y[i] > electron_y[i][Es]) {
									 forca_y[i] += electron_power;
									 } else if (forca_y[i] < electron_y[i][Es]) {
									 forca_y[i] -= electron_power;
									 }
									 }

									 if (fabs(forca_y[ii] - electron_y[ii][Es2]) <= 180) {
									 if (forca_y[ii] > electron_y[ii][Es2]) {
									 forca_y[ii] -= electron_power;
									 } else if (forca_y[ii] < electron_y[ii][Es2]) {
									 forca_y[ii] += electron_power;
									 }
									 } else {
									 if (forca_y[ii] > electron_y[ii][Es2]) {
									 forca_y[ii] += electron_power;
									 } else if (forca_y[ii] < electron_y[ii][Es2]) {
									 forca_y[ii] -= electron_power;
									 }
									 }
									 */
//									forca_y[i] = fixNegativeAngle(forca_y[i]);
//									forca_y[ii] = fixNegativeAngle(forca_y[ii]);
									printf("Alterando forcas %d\n", electron_arested[i][Es][0]);
									GLfloat forcat = forca_x[i];
									forca_x[i] = forca_x[ii];
									forca_x[ii] = forcat;
								}
//								printf("Electrons c\n");
								if (i == 0) {
									if (electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
										if (abs(show_distance2(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii])) <= (electron_raio[i] + electron_raio[ii]) + tensao[i] + tensao[ii]) {
											GLfloat d_atomo_atomo = show_distance2(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]);
											GLfloat angulo_f = toAngle(fabs(posy[i] - posy[ii]) / d_atomo_atomo);
											if (posy[i] > posy[ii] && angulo_f < 180) {
												angulo_f += 180;
											}

											// ====================== FUNCIONANDO =========================
//										// Caso esteja abaixo deve fazer com que o angulo aponte para baixo
//										if (posy[i] > posy[ii] && angulo_f < 180) {
//											angulo_f += 180;
//										}
//										GLfloat angulo_o = fixNegativeAngle(angulo_f + 180.0);
////										printf("Y: %f Angulo_f: %f  Angulo_o: %f\n", forca_y[i], angulo_f, angulo_o);
//										if (fabs(forca_y[i] - angulo_f) > tensao_giro[i]) {
//											if (angulo_f > angulo_o) {
//												if (forca_y[i] <= angulo_f && forca_y[i] >= angulo_o) {
//													forca_y[i] += tensao_giro[i];
//												} else {
//													forca_y[i] -= tensao_giro[i];
//												}
//											} else {
//												forca_y[i] -= tensao_giro[i];
//											}
//											forca_y[i] = fixNegativeAngle(forca_y[i]);
//										} else {
//											angulo_f = toAngle(fabs(posx[i] - posx[ii]) / d_atomo_atomo);
//											if (fabs(forca_z[i] - angulo_f) > tensao_giro[i]) {
//												//											printf("Angulof: %f Ay: %f\n", angulo_f, forca_y[i]);
//												if (posx[i] > posx[ii]) {
//													//												printf("Electrons e\n");
//													angulo_f += 180;
//												}
//												//											printf("Angulo1: %f y: %f \n",angulo_f, forca_y[i]);
//												if (fabs(angulo_f - forca_z[i]) <= 180 && fabs(angulo_f - forca_z[i]) > tensao_giro[i]) {
//													forca_z[i] += tensao_giro[i];
//												} else if (fabs(angulo_f - forca_z[i]) > tensao_giro[i]) {
//													forca_z[i] -= tensao_giro[i];
//												}
//												forca_z[i] = fixNegativeAngle(forca_z[i]);
//												//											printf("Angulo3: %f z: %f \n", angulo_f, forca_z[i]);
//
//												GLfloat angulo_z = toAngle(fabs(posx[i] - posx[ii]) / d_atomo_atomo);
//												if (posx[i] > posx[ii]) {
//													angulo_f += 180;
//												}
//												if (forca_z[i] >= fixNegativeAngle(angulo_f - 180) && forca_z[i] <= angulo_f) {
//													forca_z[i] += tensao_giro[i];
//												} else {
//													forca_z[i] -= tensao_giro[i];
//												}
//												forca_z[i] = fixNegativeAngle(forca_z[i]);
//											}
//										}
//
											//=======================================================================

											printf("Angulof: %f Ay: %f\n", angulo_f, forca_y[i]);

//											printf("Angulo1: %f y: %f Calculo: %f\n", angulo_f, forca_y[i], (360.0 + forca_y[i] - angulo_f));
//											if ((360.0 + forca_y[i] - angulo_f) > 180 && forca_y[i] < 180) {
//												forca_y[i] += tensao_giro[i];
//											} else {
//												forca_y[i] -= tensao_giro[i];
//											}

//											GLfloat oposto = fixNegativeAngle(forca_y + 180.0)

//											printf("Angulo2: %f y: %f \n", angulo_f, forca_y[i]);

//										printf("Resultante Y %f  Z %f\n", forca_y[i], forca_z[i]);
										}
									}
//								}
								}
							}
						}

//						if (!isclose && electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
						if (electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
//							printf("Aq %f\n", posEx[i][Es]);
//							printf("Distancia %f      Maximo %f\n", show_distance2(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2], posEz[i][Es], posEz[ii][Es2]), (electron_raio[i] + electron_raio[ii]));
							//if (show_distance2(posEx[i][Es], posEx[ii][Es2], posEy[i][Es], posEy[ii][Es2], posEz[i][Es], posEz[ii][Es2]) <= electron_raio[i] + electron_raio[ii]) {
							if (abs(show_distance2(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii])) <= (electron_raio[i] + electron_raio[ii]) + tensao[i] + tensao[ii]) {
								//if (checa_between(posEx[i][Es], posEx[ii][Es2], posx[ii], ((tensao[i] + tensao[ii]) / 2.0)) && checa_between(posEy[i][Es], posEy[ii][Es2], posy[ii], ((tensao[i] + tensao[ii]) / 2.0))) {
//								if (i == 0) {
//									printf("MF: A1y: %f A2y: %f Az1: %f Az2: %f \n", posy[i], posy[electron_arested[i][Es][0]], posz[i], posz[electron_arested[i][Es][0]]);
//									power_direcao(i,ii);

//								GLfloat d_atomo_atomo = show_distance2(posx[i], posx[ii], posy[i], posy[ii], posz[i], posz[ii]);
//								GLfloat angulo_f = toAngle(fabs(posy[i] - posy[ii]) / d_atomo_atomo);
//								if (posy[i] > posy[ii]) {
//									angulo_f += 180;
//								}
//								if (forca_y[i] >= fixNegativeAngle(angulo_f - 180) && forca_y[i] <= angulo_f) {
//									forca_y[i] += tensao_giro[i];
//
//								} else {
//									forca_y[i] -= tensao_giro[i];
//								}
//								forca_y[i] = fixNegativeAngle(forca_y[i]);
////									printf("A1y: %f A2y: %f D: %f Angulo: %f AnguloO: %f\n", posy[i], posy[ii], d_atomo_atomo, angulo_f, fixNegativeAngle(angulo_f - 180));
//
//								GLfloat angulo_z = toAngle(fabs(posx[i] - posx[ii]) / d_atomo_atomo);
//								if (posx[i] > posx[ii]) {
//									angulo_f += 180;
//								}
//								if (forca_z[i] >= fixNegativeAngle(angulo_f - 180) && forca_z[i] <= angulo_f) {
//									forca_z[i] += tensao_giro[i];
//								} else {
//									forca_z[i] -= tensao_giro[i];
//								}
//								forca_z[i] = fixNegativeAngle(forca_z[i]);

								// Segundo ta mais alto

//									if (posy[electron_arested[i][Es][0]] > posy[i]) {
//										printf("B1\n");
//										if (forca_y[i] < 90) {
//											forca_y[i] += tensao_giro[i];
//										} else if (forca_y[i] <= 270) {
//											forca_y[i] -= tensao_giro[i];
//										} else if (forca_y[i] < 360) {
//											forca_y[i] += tensao_giro[i];
//										}
//									} else if (posy[electron_arested[i][Es][0]] < posy[i]) {
//										printf("B2\n");
//										if (forca_y[i] < 90) {
//											forca_y[i] -= tensao_giro[i];
//										} else if (forca_y[i] <= 270) {
//											forca_y[i] += tensao_giro[i];
//										} else if (forca_y[i] < 360) {
//											forca_y[i] -= tensao_giro[i];
//										}
//									}

//									if (posz[electron_arested[i][Es][0]] > posz[i]) {
//										if (posx[electron_arested[i][Es][0]] > posx[i]) {
//											printf("Posx <\n");
//											if (forca_z[i] < 180) {
//												forca_z[i] -= tensao_giro[i];
//												printf("P1\n");
//											} else if (forca_z[i] <= 360) {
//												forca_z[i] += tensao_giro[i];
//												printf("P2\n");
//											}
//										} else {
//											printf("Posx > %f %f\n", posx[electron_arested[i][Es][0]], posx[i]);
//											if (forca_z[i] < 90) {
//												forca_z[i] += tensao_giro[i];
//												printf("P1\n");
//												if (posy[electron_arested[i][Es][0]] > posy[i]) {
//													printf("B1\n");
////													if (posy[i] < 90) {
////														forca_y[i] += tensao_giro[i];
////													} else if (posy[i] <= 270) {
////														forca_y[i] -= tensao_giro[i];
////													} else if (posy[i] < 360) {
////														forca_y[i] += tensao_giro[i];
////													}
//												} else if (posy[electron_arested[i][Es][0]] < posy[i]) {
//													printf("B2 %f\n",forca_y[i]);
//													if (forca_y[i] <= 180) {
//														forca_y[i] -= tensao_giro[i];
//													} else if (forca_y[i] > 180) {
//														forca_y[i] -= tensao_giro[i];
//													}
//												}
//											} else if (forca_z[i] <= 270) {
//												forca_z[i] -= tensao_giro[i];
//												printf("P2\n");
//											} else if (forca_z[i] < 360) {
//												forca_z[i] += tensao_giro[i];
//												printf("P3\n");
//											}
//										}
////										printf("B3\n");
////										if (posz[i] < 90) {
////											forca_z[i] += tensao_giro[i];
////										} else if (posz[i] <= 270) {
////											forca_z[i] -= tensao_giro[i];
////										} else if (posz[i] < 360) {
////											forca_z[i] += tensao_giro[i];
////										}
//									} else if (posz[electron_arested[i][Es][0]] < posz[i]) {
////										printf("B4 %d\n",i);
//										if (posz[i] < 90) {
//											forca_z[i] -= tensao_giro[i];
//										} else if (posz[i] <= 270) {
//											forca_z[i] += tensao_giro[i];
//										} else if (posz[i] < 360) {
//											forca_z[i] -= tensao_giro[i];
//										}
//									}
//									forca_z[i] = fixNegativeAngle(forca_z[i]);
//									forca_y[i] = fixNegativeAngle(forca_y[i]);
//									printf("MF2: A1y: %f A2y: %f Fy: %f Az1: %f Az2: %f Fz: %f\n", posy[i], posy[electron_arested[i][Es][0]], forca_y[i], posz[i], posz[electron_arested[i][Es][0]], forca_z[i]);
//								}
								//electron_y[i][Es] = fixNegativeAngle(toAngle(atan2(-(posy[i]) + posy[ii], -(posx[i]) + posx[ii])));
							} else {
//								printf("Longe\n");
								electron_arested[i][Es][0] = -1;
								electron_arested[ii][Es2][0] = -1;
							}
						} else if (electron_arested[i][Es][0] == ii && electron_arested[i][Es][1] == Es2) {
							printf("AE1\n");
//							electron_y[i][Es] = fixNegativeAngle(toAngle(atan2(-(posy[i]) + posy[ii], -(posx[i]) + posx[ii])));
							//electron_y[ii][Es2] = fixNegativeAngle(toAngle(atan2(-(posy[ii]) + posy[i], -(posx[ii]) + posx[i])));
//							if (checa_between(posEx[i][Es], posEx[ii][Es2], posx[ii], ((tensao[i] + tensao[ii]) / 2.0)) && checa_between(posEy[i][Es], posEy[ii][Es2], posy[ii], ((tensao[i] + tensao[ii]) / 2.0))) {
//								printf("AE1.1\n");

							//compare = fabs(posEx[i][Es] - posx[ii]);
							//if (compare <= collision_proximity) {
							//compare = fabs(posEy[i][Es] - posy[ii]);
							//if (compare <= collision_proximity) {
							//printf("Muito perto\n");
							//angle_power(&forca_y[i], &forca_x[i], &forca_y[ii], &forca_x[ii], &posx[i]);
							// }
//							}
						} else {
							//							printf("AE1.2\n");
							//							electron_arested[i][Es][0] = -1;
							//							electron_arested[ii][Es2][0] = -1;
						}
						//						} else if (electron_arested[i][Es][0] != -1 && electron_arested[ii][Es2][0] != -1) {
						//printf("AE2: i:%d ii:%d es:%d es2:%d EArested0:%d EArested1:%d\n", i, ii, Es, Es2, electron_arested[i][Es][0], electron_arested[i][Es][1]);
						//						} else {
						//printf("NuNo\n");
						//						}
					}
				}
			}
		}

		glTranslatef(-posx[i], -posy[i], -posz[i]);

		// ================ Checa colisao de nucleo com electron ================
		compare = 0.0;
		compare2 = 0.0;
		for (GLint ii = 0; ii < atomos_quantidade; ii++) {
			if (i != ii) {
//				break;
//			}
				for (GLint Es = 0; Es < electron_quantidade[i]; Es++) {
					if (electron_arested[i][Es][0] == ii) {
						if (show_distance2(posEx[i][Es], posx[ii], posEy[i][Es], posy[ii], posEz[i][Es], posz[ii]) <= nucleo_proximity[ii]) {
							angle_power2(&forca_y[i], &forca_z[i], &forca_x[i], &forca_y[ii], &forca_z[ii], &forca_x[ii]);
//							if (i == 0) {
//								printf("AAA\n");
//							}
							//printf("Colisao E com Nucleo %f %f %d\n", posx[i], posEx[0][0], electron_arested[i][Es][0]);
							//printf("Colisao E com Nucleo %f %f %f\n", posEx[i][Es], posx[i], show_distance2(posEx[i][Es], posx[ii], posEy[i][Es], posy[ii], posEz[i][Es], posz[ii]));
						}
						//}
						/*
						 compare = fabs(posEx[i][Es] - posx[ii]);
						 if (compare <= nucleo_proximity[i]) {
						 compare2 = fabs(posEy[i][Es] - posy[ii]);
						 if (compare2 <= nucleo_proximity[i]) {
						 //	printf("Colisao NE %f | %f | %f | %f | %f\n", compare, compare2, nucleo_proximity[i], posEy[i][Es], posy[ii]);
						 //	angle_power(&forca_y[i], &forca_x[i], &forca_z[i], &forca_y[ii], &forca_z[ii], &forca_x[ii], &posx[i]);
						 angle_power2(&forca_y[i], &forca_z[i], &forca_x[i], &forca_y[ii], &forca_z[ii], &forca_x[ii]);
						 if (compare < nucleo_proximity[i] && compare2 < nucleo_proximity[i]) {
						 //									printf("Compare: %f %f MP %f \n", compare, compare2, nucleo_proximity[i]);
						 if (posy[i] > posy[ii]) {
						 //										posx[i] += nucleo_proximity[i] - compare2;
						 //										posx[ii] -= nucleo_proximity[ii] - compare2;
						 } else {
						 //										posx[i] -= nucleo_proximity[i] - compare2;
						 //										posx[ii] += nucleo_proximity[ii] - compare2;
						 }
						 if (posx[i] > posx[ii]) {
						 //										posx[i] += nucleo_proximity[i] - compare;
						 //										posx[ii] -= nucleo_proximity[ii] - compare;
						 } else {
						 //										posx[i] -= nucleo_proximity[i] - compare;
						 //										posx[ii] += nucleo_proximity[ii] - compare;
						 }
						 }
						 }
						 }
						 */
					}
				}
			}
		}
	}

	if (cont_loop_electron == cont_loop_electron_time) {
		cont_loop_electron = 0;
	}
	cont_loop_electron++;

// ===================================================
// ----- Stop Drawing Stuff! ------
	glfwSwapBuffers();						// Swap the buffers to display the scene (so we don't have to watch it being drawn!)
}

// Called like:
//changeThem(&a, &b);

// Fire it up...
int main(int argc, char **argv) {
	cout << "Controls: Use WSAD and the mouse to move around!" << endl;

// Frame counter and window settings variables
	int redBits = 8, greenBits = 8, blueBits = 8;
	int alphaBits = 8, depthBits = 24, stencilBits = 0;

// Flag to keep our main loop running
	bool running = true;

// ----- Intialiase FreeGLUT -----

// Note: We're only using freeGLUT to draw some spheres, so if you modify the code to not include any calls
// to glutSolidSphere, then you don't need this, the header or the lib...
	glutInit(&argc, argv);

// Initialise GLFW
	glfwInit();

// Ask for 4x AntiAliasing (this doesn't mean we'll get it - it'll work only if the GLX_ARB_multisample extension is available)
// Note: Hints must be provided BEFORE the window is opened! But we can't query for it with GLEE until the window is opened! Catch 22!
	glfwOpenWindowHint(GLFW_FSAA_SAMPLES, 4);

// Create a window
	if (!glfwOpenWindow(windowWidth, windowHeight, redBits, greenBits, blueBits, alphaBits, depthBits, stencilBits, GLFW_WINDOW)) {
		cout << "Failed to open window!" << endl;
		glfwTerminate();
		return 0;
	}

// ----- Initialise GLEE -----

// Initialise GLee once we've got a rendering context
// Note: We don't really have to do this because it's called automatically, but if we do it - we KNOW it's been called!
	GLeeInit();

// Check for the OpenGL extension which allows us to use vsync
	if (GLEE_GLX_SGI_swap_control) {
		cout << "Extension found: GLX_SGI_swap_control (vsync can be used)." << endl;
		glfwSwapInterval(1);
	} else {
		cout << "Extension NOT found: GLX_SGI_swap_control (vsync cannot be used)." << endl;
		glfwSwapInterval(0);
	}

// Check for the OpenGL extension which allows us to use antialiasing
	if (GLEE_ARB_multitexture) {
		cout << "Extension found: GLX_ARB_multitexture (anti-aliasing can be used)." << endl;

// If the extension's available, we likely got anti-aliasing, so disable line smoothing as it comes free with the AA
		glDisable(GL_LINE_SMOOTH);
	} else {
		cout << "Extension NOT found: GLX_ARB_multitexture (anti-aliasing cannot be used)." << endl;

// If the extention's not available, turn on line smoothing
		glEnable(GL_LINE_SMOOTH);
	}

// Set the mouse cursor to the centre of our window
	glfwSetMousePos(midWindowX, midWindowY);

// Call our initGL function to set up our OpenGL options
	initGL();

// Specify the function which should execute when a key is pressed or released
	glfwSetKeyCallback(handleKeypress);

// Specify the function which should execute when the mouse is moved
	glfwSetMousePosCallback(handleMouseMove);

	while (running == true) {
		calculaposicoes();

// Draw our scene
		drawScene();

// Calculate our camera movement
		calculateCameraMovement();

// Move our camera
		moveCamera();

// Increase our frame counter
		frameCount++;

// Check for any OpenGL errors (providing the location we called the function from)
		checkGLError("Main loop");

// exit if ESC was pressed or window was closed
		running = !glfwGetKey(GLFW_KEY_ESC) && glfwGetWindowParam(GLFW_OPENED);
	}

// Clean up GLFW and exit
	glfwTerminate();

	return 0;
}
